/**
 * This was created using the Turbo Rascal Syntax Error development platform.
 * 
 * https://turborascal.com
 * https://github.com/leuat/TRSE
 *
 * License: GPL V3
 *
 * Enhanced version of KALEIDOSCOPE from:
 *  "32 BASIC Programs for the PET Computer" Tom Rugg and Phil Feldman (1979)
 * 
 * Author: Jessica Petersen <fuzzybad@gmail.com> (Nov 2021)]
 *
 * This is a much extended version of the KALEIDO routine. The pattern will reverse,
 * randomly select different characters and move about the screen over time.
 * It also supports full-screen mode (original was 24x24 only) and supports 80-col PETs.
 * 
 */
program Kaleido;
var  
	// Main program vars
	myscreenheight	: byte = 24;
	myscreenwidth	: byte = 80;
	centerX 	  		: byte = 40;
	centerY 	  		: byte = 12;
	start_pos 	  	: byte = 1;
	stop_pos 	  	: byte = 12;
	dir			  	: byte = 1;
	char_start 	  	: byte;
	char_offset   	: byte;
	char_start_st 	: byte = 65;	// Save state of char_start
	char_offset_st	: byte = 62;	// Save state of char_offset
	num_chars	  	: byte = 6;	// Number of chars in the array
	speed 		  	: byte = 3;	// Recommended values 0-9
	rev_enable	  	: byte = 0;	// 0=Disable, 1=Enable reverse chars
	pattern_type  	: byte = 1;	// 0=4-Point Pattern, 1=8-Point Pattern
	full_screen   	: byte = 1;	// Flag for full-screen mode
	curr_color		: byte = 1;	// Current color
	char_arr 	  	: array[12] of byte;
	p 			  	: pointer;
	plotIndex, plotIndexMax, mainIndex, colSelect, i, temp : signed byte;
	tempint			: integer;
	x1, y1, x2, y2	: signed byte;

	// Used for keyboard input
	key: byte;
	
	// Text for splash screen  	
	titlemsg:	cstring = ("KALEIDOSCOPE+");
	authormsg1: 	cstring = ("JESSICA PETERSEN <FUZZYBAD>, 2021");
	authormsg2: 	cstring = ("BASED ON ROUTINE BY");
	authormsg3: 	cstring = ("RUGG AND FELDMAN, 1979");
	inst1: 		cstring = ("0-9 - ADJUST SPEED");
	inst2: 		cstring = ("Q   - QUIT");
	inst3:		cstring = ("PLEASE SWITCH TO 80 COLUMN SCREEN");
	// PRESS ANY KEY
	//promptmsg: cstring = (208, 210, 197, 211, 211, 32, 193, 206, 217, 32, 203, 197, 217);
	promptmsg: cstring = ("PRESS ANY KEY");

//	Method to get a char from the keyboard buffer
//	TRSE procedures return accumulator value
procedure GetKey();
begin
	call(^$ffe4);	// getin
end;

// Wait for user input
procedure WaitForKeypress();
begin
	// Pause until key pressed
	temp := 0;
	while( temp = 0 ) do begin
		temp := GetKey();
	end;
end;

// Do timing delay 
// @TODO: Find better way than delay loop
procedure DoDelay();
begin
	if( speed > 0 ) then
	begin
		for i := 0 to speed do	
		begin
			wait(255);
		end;
	end;
end;

// Clear 80-col screen
//	Clear80(32, $00); // fill screen with spaces
//	Clear80(8, $08); // fill screen color
procedure Clear80( myChar:byte, myLoc:integer );
begin
	for i := 0 to 25 do
	begin
		MoveTo80(0, i, myLoc);
		Fill80(myChar, 80); // space char
	end;
end;

// Debug up to 3 numeric vars
procedure PrintXYZ( myX:signed byte, myY:signed byte, myZ:signed byte );
begin
	// Erase & print values
	moveto(1, 5, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myX, 2);

	moveto(1, 6, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myY, 2);

	moveto(1, 7, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myZ, 2);
end;
 
//	Method which shows title screen and checks screen width
procedure ShowTitle();
begin
	// Set 80-col screen
	Go80Columns();

	Clear80(32, 0);	// Init VDC screen mem
	Clear80(3, 8);	// Init VDC color mem 

	// Set uppercase
	//poke(^59468, 0, 12);
	
	// Set background/border colors (40-col)
	poke(SCREEN_BG_COL, 0, BLACK);
	poke(SCREEN_FG_COL, 0, BLACK);
	
	// Clear screen (40-col)
	clearscreen($20, SCREEN_CHAR_LOC);
	// Set cyan color (40-col)
	clearscreen(3, SCREEN_COL_LOC);	
	

	// Show message to switch to 80 columns on VIC screen
	x1 := SCREEN_WIDTH / 2 - length(inst3) / 2;
	MoveTo(x1, 8, hi(SCREEN_CHAR_LOC));
   	PrintString(#inst3, 0, length(inst3));
	
	// VDC text matrix is at $0000
	// VDC color matrix is at $0800

	// Center the title text on VDC screen 
	x1 := myscreenwidth / 2 - length(titlemsg) / 2;
	// Fill color for string
	MoveTo80(x1, 1, $08);
	Fill80(13, length(titlemsg)); // yellow
	// Display text	
	MoveTo80(x1, 1, $00);
	Print80(#titlemsg, length(titlemsg));

	// Center the author message
	x1 := myscreenwidth / 2 - length(authormsg1) / 2;
	// Fill color for string
	MoveTo80(x1, 3, $08);
	Fill80(5, length(authormsg1)); // green
	// Display text	
	MoveTo80(x1, 3, 0);
   	Print80(#authormsg1, length(authormsg1));

	x1 := myscreenwidth / 2 - length(authormsg2) / 2;
	// Fill color for string
	MoveTo80(x1, 6, $08);
	Fill80(7, length(authormsg2)); // cyan
	// Display text	
	MoveTo80(x1, 6, 0);
   	Print80(#authormsg2, length(authormsg2));

	x1 := myscreenwidth / 2 - length(authormsg3) / 2;
	// Fill color for string
	MoveTo80(x1, 8, $08);
	Fill80(7, length(authormsg3)); // cyan
	// Display text	
	MoveTo80(x1, 8, 0);
   	Print80(#authormsg3, length(authormsg3));

	// Display Controls
	x1 := 31;
	// Fill color for string
	MoveTo80(x1, 12, $08);
	Fill80(15, length(inst1)); // white
	// Display text	
	MoveTo80(x1, 12, 0);
    Print80(#inst1, length(inst1));

	// Fill color for string
	MoveTo80(x1, 14, $08);
	Fill80(15, length(inst2)); // white
	// Display text	
	MoveTo80(x1, 14, 0);
    Print80(#inst2, length(inst2));

	// Center prompt to continue
	x1 := myscreenwidth / 2 - length(promptmsg) / 2;
	MoveTo80(x1, 24, $08);
	//	Fill80(23, length(promptmsg)); // cyan blinking
	//	Fill80(71, length(promptmsg)); // cyan reverse
	Fill80(87, length(promptmsg)); // cyan blinking reverse
	// Display text
	MoveTo80(x1, 24, 0);
   	Print80(#promptmsg, length(promptmsg));
   	
	WaitForKeypress();
end;

// Fill char array
procedure InitData();
begin	
	for i := 0 to num_chars do							// line 150
	begin
		// Populate char_arr 
		char_start	:= char_start_st;
		char_offset	:= char_offset_st;
		
		// Option for reverse chars
		if( rev_enable = 1 ) then
		begin
			if( Random() > 127 ) then				// line 165
				char_start := char_start + 128;		// line 165
		end;
		
		char_arr[i] := Random() & char_offset + char_start;
	end;
end; 

// Check for any user inputs
procedure CheckInputs();
begin	
	key := GetKey();

	// Q - Quit
	if(key = 81) then begin
		call(^65341); // Reboot
		//call(^$fffc); // RESET
		//call(^$fffe); // NMI
	end;
	
	// 0-9 Adjust speed 
	if(key = 48) then speed := 9; // (slowest)
	if(key = 49) then speed := 8;
	if(key = 50) then speed := 7;
	if(key = 51) then speed := 6;
	if(key = 52) then speed := 5;
	if(key = 53) then speed := 4;
	if(key = 54) then speed := 3;
	if(key = 55) then speed := 2;
	if(key = 56) then speed := 1;
	if(key = 57) then speed := 0; // (fastest)
end;


// Poke value into an address
procedure PokeAddr(pokeaddr_x:byte, pokeaddr_y:byte, pokeaddr_v:byte);
begin
	if( pokeaddr_x > myscreenwidth -2) then return;
	if( pokeaddr_x < 0) then return;
	if( pokeaddr_y > myscreenheight ) then return;
	if( pokeaddr_y < 0) then return;

	if( myscreenwidth = 40 ) then
	begin
		// VIC screen plot
		
		// Pointer value to screen RAM
		//p := SCREEN_CHAR_LOC + SCREEN_WIDTH * pokeaddr_y + pokeaddr_x;
		//poke(p, 0, pokeaddr_v);
	
		// Pointer value to color RAM
		//p := SCREEN_COL_LOC + SCREEN_WIDTH * pokeaddr_y + pokeaddr_x;
		//poke(p, 0, curr_color);
	end else
	begin
		// VDC screen plot
		
		// $D600 is VDC Address Register
		// $D601 is VDC Data Register
		// VDC Character Display area (screen) $0000-$07FF
		// VDC Character Attributes (color) $0800-$0FFF
		// VDC Character Definitions $2000-$3FFF
	
		// Fill color for string
		MoveTo80(pokeaddr_x, pokeaddr_y, $08);
		Fill80(curr_color, 2);
		
		// Display text
		MoveTo80(pokeaddr_x, pokeaddr_y, $00);
		Fill80(pokeaddr_v, 2);

		// Alternately, select char from string by index 
		//temp := outstr[0];
		//Fill80(temp, 2);

		// Debug
		//PrintXYZ(pokeaddr_x, pokeaddr_y, pokeaddr_v);
		//WaitForKeypress();
	end;
end;


//////////////////////////
// Plot chars on screen
//////////////////////////
procedure Plot();
begin
	// Debug
	//PrintXYZ(x2, y2, 0);
	//WaitForKeypress();

	// Call timing delay
	DoDelay();

	// Map points in the four indexes
	PokeAddr(x1, y1, char_arr[0]);				// line 900
	//PokeAddr(x1, y1, outstr[0]);					// line 900

	if( mainIndex = 1 ) then return;				// line 910
	
	colSelect := mainIndex / 2 + 1;				// line 920

	// Modifies character range selection and will take effect 
	// next time InitData() runs
	char_start := mainIndex - colSelect - 1;		// line 920

	// Select pattern style
	if( pattern_type = 1 ) then plotIndexMax := colSelect 
	else plotIndexMax := mainIndex;

	// Map chars surrounding the up/down/across indexes
	for plotIndex := 1 to plotIndexMax do			// line 930
	begin
		if( x1 = centerX ) then					// line 940
		begin
			x2 := x1 + plotIndex;
			y2 := y1;
			// Fills right of vertical
			PokeAddr(x2, y2, char_arr[plotIndex]);
			//PokeAddr(x2, y2, outstr[plotIndex]);
			x2 := x1 - plotIndex;
			// Fills left of vertical
			PokeAddr(x2, y2, char_arr[plotIndex]);
			//PokeAddr(x2, y2, outstr[plotIndex]);
		end 
		else if( y1 = centerY ) then			// line 950
		begin
			x2 := x1;
			y2 := y1 + plotIndex;
			// Fills below horizontal
			PokeAddr(x2, y2, char_arr[plotIndex]);
			//PokeAddr(x2, y2, outstr[plotIndex]);
			y2 := y1 - plotIndex;
			// Fills above horizontal
			PokeAddr(x2, y2, char_arr[plotIndex]);
			//PokeAddr(x2, y2, outstr[plotIndex]);
		end
		else begin
			y2 := y1;						// line 970
			if( x1 < centerX ) then				// line 970
			begin
				// Fills left side diagonal
				x2 := x1 + plotIndex;
				PokeAddr(x2, y2, char_arr[plotIndex]);
				//PokeAddr(x2, y2, outstr[plotIndex]);
			end else begin
				// Fills right side diagonal
				x2 := x1 - plotIndex;		// line 980
				PokeAddr(x2, y2, char_arr[plotIndex]);
				//PokeAddr(x2, y2, outstr[plotIndex]);
			end;
			
			x2 := x1;						// line 990
			
			if( y1 < centerY ) then			// line 990
			begin
				// Fills top corners
				y2 := y1 + plotIndex;
				PokeAddr(x2, y2, char_arr[plotIndex]);					
				//PokeAddr(x2, y2, outstr[plotIndex]);
			end
			else begin
				// Fills bottom corners
				y2 := y1 - plotIndex;		// line 1000
				PokeAddr(x2, y2, char_arr[plotIndex]);
				//PokeAddr(x2, y2, outstr[plotIndex]);
			end;
		end;
	end; // for
end;

// Update the display
procedure MainLoop();
begin
	for mainIndex := start_pos to stop_pos step dir do	// line 200
	begin		
		// Update color
		curr_color := Random() & 15;
		// If black, pick another color..
		while( curr_color = 0 ) do curr_color := Random() & 15;
		
		// Map the data
		// Right
		x1 := centerX + mainIndex;			// line 210
		y1 := centerY;						// line 210
		Plot();								// line 210
		// Left
		x1 := centerX - mainIndex;			// line 220
		Plot();								// line 220
		// Down
		x1 := centerX;						// line 230
		y1 := centerY + mainIndex;			// line 230
		Plot();								// line 230
		// Up
		y1 := centerY - mainIndex;			// line 240
		Plot();								// line 240

		// Lower right
		x1 := centerX + mainIndex;			// line 250
		y1 := centerY + mainIndex;			// line 250
		Plot();								// line 250
		// Upper left
		x1 := centerX - mainIndex;			// line 260
		y1 := centerY - mainIndex;			// line 260
		Plot();								// line 260
		// Lower left
		y1 := centerY + mainIndex;			// line 270
		Plot();								// line 270
		// Upper right
		x1 := centerX + mainIndex; 			// line 280
		y1 := centerY - mainIndex;			// line 280
		Plot();								// line 280
		
		// Check for user input	
		CheckInputs();
	end;
end;

// Various Pattern Mutations
procedure DoMutations();
begin
	// Reverse direction (1/2 cycle)
	dir			:= -dir;
	temp			:= start_pos;
	start_pos	:= stop_pos;
	stop_pos		:= temp;

	temp := Random();

	// Mutations every full cycle
	if( dir = 1 ) then
	begin
		// Toggle pattern type
		if( pattern_type = 1 ) then 
		begin						// 4-point pattern
			pattern_type := 0;
			num_chars := myscreenheight / 2;
		end
		else begin 					// 8-point pattern
			pattern_type := 1;
			num_chars := myscreenheight / 4;
		end;

		// Randomly change center point
		if( temp < 128 ) then
		begin
			// Determines width & height of area where pattern originates
			centerX := Random();
			while( centerX < 15 or centerX > 65 ) do centerX := Random();
			centerY := Random();
			while( centerY < 6 or centerY > 18 ) do centerY := Random();
		end;

		// Clear screen once in a while
		if( temp < 4 ) then	Clear80(32, 0);
	end;

	// Select char range
	if( temp < 32 ) then
	begin
		//if( temp < 11 ) then
		//begin
		//	char_start_st	:= 234;
		//	char_offset_st	:= 22;
		//end
		//else if ( temp < 22 ) then

		if ( temp < 16 ) then
		begin
			char_start_st	:= 96;
			char_offset_st  	:= 31;		
		end	else 
		begin
			char_start_st	:= 65;
			char_offset_st	:= 62;
		end;	
	end;

	// Toggle reverse chars
	if( Random() < 64 )	then
	begin
		if( rev_enable = 1 ) then rev_enable := 0 
		else rev_enable := 1;
	end;
	
	// Toggle pattern size
	if( Random() < 128 ) then
	begin
		// Set pattern moving outward
		dir := 1;
		start_pos := 1;

		// Toggle the flag
		if( full_screen = 0 ) then 
		begin
			full_screen	:= 1;
			stop_pos		:= 24;
		end
		else begin
			full_screen	:= 0;
			stop_pos		:= 12;
		end;
		
		//clearscreen($20, SCREEN_CHAR_LOC);
//		Clear80(32, 0); 
	end;

	// Debug
	//PrintXYZ(temp, 0, 0);
	//WaitForKeypress();
	//call(^$fd49);	// Trigger NMI	
end;


begin
	// Show the title and check number of columns
	ShowTitle();	

	// Set 2 mhz mode
	Set2MhzMode();
	//poke(^53296, 0, 1);  	//	2Mhz (works in both 64 and 128 mode) POKE 53296,1
	//poke(^53296, 0, 0);	//	1Mhz (works in both 64 and 128 mode) POKE 53296,0
	
	// Init char array	
	InitData();

	Clear80(32, 0);	// Init VDC screen mem
	Clear80(3, 8);	// Init VDC color mem 
	
	while (true) do begin
		MainLoop();

		// Pattern modifications
		DoMutations();
		
		// Get fresh array of chars
		InitData();
	end;
end.

// eof
