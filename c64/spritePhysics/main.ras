 /**
 *	C64 Sprite Physics demo
 *	JLP 2023 (fuzzybad@gmail.com)
 */
 
program SpritePhysics;

@use "input/key"	

var
	const	LOC_SCREEN_BORD:	address = 53280; 	// Border color 
	const	LOC_SCREEN_BACK:	address = 53281; 	// Background color 0
	const	LOC_SPRITE_PTRS:	address = 2040;		// location of sprite data
	const	SPRITE_X_HOME: integer = 1580;		// Default X pos
	const	SPRITE_Y_HOME: integer = 640;			// Default Y pos
	
	loc_work:	pointer;
	
	// $3FC-$3FF are unused
	i : byte at $3FC;

	// NOTE: Position & inc vars are x10, in order to calculate fracional values
	//
	//   20 x=165: y=64: dx=0: dy=0: r=0
	sprite_x 	: signed integer = SPRITE_X_HOME;
	sprite_y 	: signed integer = SPRITE_Y_HOME;
	dir_x		: signed integer = 0;
	dir_y		: signed integer = 0;
	max_x		: byte = 100;
	max_y		: byte = 80;
	inc_amt		: byte = 10;
	sprite_x_hi	: byte = 0;
	phyx_enable	: byte = 1;
	//border_rt 	: integer = 480 + 24;	// right border
	border_rt 	: integer = 3030 + 24;	// right border
	border_lt	: integer = 240 - 24;	// left border
	border_tp	: integer = 0;// 500;
	border_bt	: integer = 2080;

	//   40 v=53248
	// not needed

	//  300 data 0,127,0,1,255,192,3,255,224,3,231,224
	//  310 data 7,217,240,7,223,240,7,217,240,3,231,224
	//  320 data 3,255,224,3,255,224,2,255,160,1,127,64
	//  330 data 1,62,64,0,156,128,0,156,128,0,73,0,0,73,0
	//  340 data 0,62,0,0,62,0,0,62,0,0,28,0
	sprite_data_arr : array[63] of byte = (
		0,127,0,1,255,192,3,255,224,3,231,224,
		7,217,240,7,223,240,7,217,240,3,231,224,
		3,255,224,3,255,224,2,255,160,1,127,64,
		1,62,64,0,156,128,0,156,128,0,73,0,0,73,0,
		0,62,0,0,62,0,0,62,0,0,28,0
	);// at 832;


// Delay function
procedure do_delay( delay_val: byte );
var
	dd_i : byte;
begin
	if( delay_val > 0 ) then	begin
		for dd_i := 0 to delay_val do wait(255);
	end;
end;


procedure checkInput();
begin
	// Read Keyboard
	//  100 get a$
	Key::Read();

	// Check cursor up/down
	//  110 if a$="{up}" then dy=dy-1
	//  120 if a$="{down}" then dy=dy+1
	if Key::Held(KEY_KW) then dir_y := dir_y - inc_amt;	// up
	if Key::Held(KEY_KS) then dir_y := dir_y + inc_amt;	// down	

	// Check cursor left/right
	//  130 if a$="{left}" then dx=dx-1
	//  140 if a$="{rght}" then dx=dx+1
	if Key::Held(KEY_KA) then dir_x := dir_x - inc_amt;	// left
	if Key::Held(KEY_KD) then dir_x := dir_x + inc_amt;	// right

	//  150 if a$=" " then dx=0: dy=0: x=165: y=64
	if Key::Held(KEY_KSPACE) then 
	begin
		dir_x := 0;
		dir_y := 0;
		sprite_x := SPRITE_X_HOME;
		sprite_y := SPRITE_Y_HOME;
	end;

	// Toggle physics
	if Key::Held(KEY_KG) then 
	begin
		if phyx_enable then begin
			phyx_enable := 0;
			poke(^$d021, 0, 4);
		end else begin
			phyx_enable := 1;			
			poke(^$d021, 0, 0);
		end;
		
		// cheap debounce
		do_delay(50);
	end;

end;


procedure updateState();
begin	
	// Debug
	//moveto(0,0,hi(screen_char_loc));
	//printdecimal(dir_x,3);
	
	// Background collision reverses direction 
	//  245 if (peek(v+31)and1) then poke 53280,(peek(53280)+1) and 15: y=y-dy*2: dy=-dy*.6
	if (peek(^$D01F,0) & 1) then 
	begin
		//inc(^$D020); // flash border
		
		// Reverse direction
		dir_y := dir_y - (dir_y * 2);	 // Workaround to set negative value	
		
		sprite_y := sprite_y + dir_y;

		// Reduce velocity on impact	
		if phyx_enable then begin
			if( dir_y < 0 ) then dir_y := dir_y + 9;
		end;
		
	end;
	
	// Update rate of change to simulate physics
	//  160 dx=dx*.95
	//  170 dy=dy+.3
	if (phyx_enable) then
	begin
		// Decay X-dir
		if (0 < abs(dir_x)) then 
		begin
			if (0 < dir_x) then begin
				dir_x := dir_x - 1;
			end else begin
				dir_x := dir_x + 1;
			end;
		end;

		// Decay Y-dir (always moves down)
		dir_y := dir_y + 1;
	end;

	// Check max rates
	if (dir_x < 0) then begin
		if (abs(dir_x) > max_x) then dir_x := dir_x + inc_amt;
	end else begin
		if (abs(dir_x) > max_x) then dir_x := dir_x - inc_amt;
	end;
	
	if (dir_y < 0) then begin
		if (abs(dir_y) > max_y) then dir_y := dir_y + inc_amt;
	end else begin
		if (abs(dir_y) > max_y) then dir_y := dir_y - inc_amt;
	end;

	// Update position
	//  180 x=x+dx: y=y+dy
	sprite_x := sprite_x + dir_x;

	// Only move up/down while sprite is onscreen
	if ( (border_lt < sprite_x and sprite_x_hi = 0)
      or (sprite_x < border_rt and sprite_x_hi = 1)
       ) then begin
		sprite_y := sprite_y + dir_y;	
	end;

	// Check X-boundaries.  
	// Going offscreen left-right wraps around
	/*
	//  190 if x<0 and r=0 then x=89: r=1
	if (sprite_x < border_lt and sprite_x_hi = 0) then begin
		sprite_x := border_rt;
		sprite_x_hi := 1;
	end;
	
	//  200 if x>255 and r=0 then x=0: r=1
	if (2550 < sprite_x and sprite_x_hi = 0) then begin
		sprite_x := 0;
		sprite_x_hi := 1;
	end;

	//  210 if x<0 and r=1 then x=255: r=0
	if (sprite_x < 0 and sprite_x_hi) then begin
		sprite_x := 2550;
		sprite_x_hi := 0;
	end;
	
	//  220 if x>89 and r=1 then x=0: r=0
	if (border_rt < sprite_x and sprite_x_hi) then begin
		sprite_x := border_lt;
		sprite_x_hi := 0;
	end;
	*/
	if (sprite_x < border_lt) then sprite_x := border_rt;
	if (border_rt < sprite_x) then sprite_x := border_lt;

	// Check Y-boundaries.  
	// Hitting top/botton reverses direction
	//
	//  230 if y<1 then y=1: dy=0
	if (sprite_y < border_tp) then begin	
		sprite_y := border_tp;
		dir_y := abs(dir_y);
	end;

	//  240 if y>208 then y=208: dy=-dy*.6
	if (border_bt < sprite_y) then begin
		sprite_y := border_bt;
		dir_y := dir_y - (dir_y * 2); // Workaround to set negative value	
		
		// Reduce velocity on impact
		if phyx_enable then dir_y := dir_y + 6;
	end;

end;


procedure updateScreen();
var
	sprite_x_tmp : integer;
	sprite_y_tmp : byte;
begin
	// Debug
	//moveto(0,0,hi(screen_char_loc));
	//printdecimal(sprite_y_int,3);

	// Sprite 0 hi-X bit
	//  250 if r=0 then poke v+16,0: goto 270
	//  260 poke v+16,1	
	//if (sprite_x_hi) then begin
	//	ToggleBit(^$D010, 0, 1);
	//end else begin
	//	ToggleBit(^$D010, 0, 0);
	//end;
	
	sprite_x_tmp := sprite_x / 10;
	sprite_y_tmp := sprite_y / 10;

	// Sprite 0 position
	//  270 poke v,x
	//  280 poke v+1,y
	//poke(^$D000, 0, sprite_x / 10);
	//poke(^$D001, 0, sprite_y / 10);
	SpritePos(sprite_x_tmp, sprite_y_tmp, 0);
end;


procedure setup();
begin
	// Clear screen, set black background & border
	//   10 print "{clr}" poke 53281,0: poke 53280,0
	ClearScreen( 32, SCREEN_CHAR_LOC); // init screen ram
	ClearScreen( BLUE, SCREEN_COL_LOC); // init color ram
	LOC_SCREEN_BACK := 0;
	LOC_SCREEN_BORD := 0;

	// Draw lines on screen
	//   15 for a=0 to 15: poke 1024+a+40*15,160: next
	//   16 for a=25 to 39: poke 1024+a+40*15,160: next
	loc_work := SCREEN_CHAR_LOC + 40 * 15;
	for i := 0 to 15 do loc_work[i] := 160; 
	for i := 25 to 40 do	loc_work[i] := 160;
	
	loc_work := SCREEN_CHAR_LOC + 40 * 24;
	for i := 0 to 40 do loc_work[i] := 160; 

	// sprite data 
	//   30 poke 2040,13: for s=0 to 62: read sd: poke 832+s,sd: next
	poke(LOC_SPRITE_PTRS, 0, 13);
	loc_work := 832;
	for i := 0 to 63 do loc_work[i] := sprite_data_arr[i];

	// enable sprite 0
	//   50 poke v+21,1
	SPRITE_BITMASK		:= %00000001;	// enable sprite 0
	
	// set sprite 0 color
	//   60 poke v+39,3
	SPRITE_COLOR[0]		:= cyan;
	SPRITE_MULTICOLOR	:= %00000000;	// disable multicolor 
	
	// set sprite 0 X/Y expansion
	//   70 poke v+23,1: poke v+29,1
	SPRITE_STRETCH_X		:= %00000001;	// expand sprites
	SPRITE_STRETCH_Y		:= %00000001;
end;


// Execution starts here
begin
	DefineScreen();
	setup();
	
	while(1) do
	begin
		waitforverticalblank();

		checkInput();
		updateState();
		updateScreen();
		
		//do_delay(10);
		//  290 goto 100			
	end;
end.

// eof