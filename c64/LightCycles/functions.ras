/* 
Tron Light Cycles - Game Functions 
*/

// Predefine these to prevent error
procedure init_gamestate();
procedure init_engine_sound();
procedure alternate_engine_sound();
procedure player_crash();
procedure sark_move();
procedure draw_title_screen_box();
procedure play_title_animation();
procedure help_screen();
procedure wipe_bike_trails();
procedure animate_game_logo();
procedure update_screen();
procedure easter_egg_move_player();

// Read input devices for title screen
procedure check_input();
var
	ci_val : byte;
begin
	// Initialize
	player_1_input	:= 0;
	player_2_input	:= 0;
	player_1_fire	:= 0;
	player_2_fire	:= 0;
	keybd_input		:= 0;

	// Joysticks and keyboard conflict, so have to choose
	// one or the other
 	if (control_mode = 1 ) then
 	begin
		// Check Joystick inputs
		ci_val := LOC_PORT_A;
		if (not ci_val & 1) then player_2_input := 3;	// Up
		if (not ci_val & 2) then player_2_input := 4;	// Down
		if (not ci_val & 4) then player_2_input := 1;	// Left
		if (not ci_val & 8) then player_2_input := 2;	// Right
		if (not ci_val & 16) then player_2_fire := 1;	// Fire
		
		// Check Joystick inputs
		ci_val := LOC_PORT_B;
		if (not ci_val & 1) then player_1_input := 3;	// Up
		if (not ci_val & 2) then player_1_input := 4;	// Down
		if (not ci_val & 4) then player_1_input := 1;	// Left
		if (not ci_val & 8) then player_1_input := 2;	// Right
		if (not ci_val & 16) then player_1_fire := 1;	// Fire
	end;
	
	// Read Keyboard
	Key::Read();

	// Values for keyboard
 	if (control_mode = 0 ) then
 	begin
		if Key::Held(KEY_KA) then player_1_input := 1;	// A - P1 Left
		if Key::Held(KEY_KJ) then player_2_input := 1;	// J - P2 Left
		if Key::Held(KEY_KD) then player_1_input := 2;	// D - P1 Right
		if Key::Held(KEY_KL) then player_2_input := 2;	// L - P2 Right
		if Key::Held(KEY_KW) then player_1_input := 3;	// W - P1 Up
		if Key::Held(KEY_KI) then player_2_input := 3;	// I - P2 Up
		if Key::Held(KEY_KS) then player_1_input := 4;	// S - P1 Down
		if Key::Held(KEY_KK) then player_2_input := 4;	// K - P2 Down
		if Key::Held(KEY_KSPACE) then player_1_fire := 1;	// Space - P1 Fire
		if Key::Held(KEY_KRSHIFT) then player_2_fire := 1;	// RShift - P2 Fire
	end;
	
	if Key::Held(KEY_KF1) then keybd_input := 4; // 1000, 1008	// F1 Key - Instructions	
	if Key::Held(KEY_KF3) then keybd_input := 5; // 2000, 2008	// F3 Key - Game Mode
	if Key::Held(KEY_KF5) then keybd_input := 6; // 4000, 4008	// F5 Key - Difficulty (works)
	if Key::Held(KEY_KF7) then keybd_input := 7; // 0800, 0808	// F7 Key - Controls
	if Key::Held(KEY_KRUNSTOP) then keybd_input := 8; // 8007, 8008 // Run/Stop Key - Abort game

	// Check shifted keys
	//if ( Key::Held(KEY_KRSHIFT) or Key::Held(KEY_KLSHIFT) ) then begin
	//	if Key::Held(KEY_KF1) then keybd_input := 11; 	// F2 Key - 
	//	if Key::Held(KEY_KF3) then keybd_input := 12; 	// F4 Key - 
	//	if Key::Held(KEY_KF5) then keybd_input := 13; 	// F6 Key - 
	//	if Key::Held(KEY_KF7) then keybd_input := 14; 	// F8 Key - 
	//end;
	//
	//if Key::Held(KEY_K1) then keybd_input := 1;	// 1 Key
	//if Key::Held(KEY_K2) then keybd_input := 2;	// 2 Key
	//if Key::Held(KEY_K3) then keybd_input := 3;	// 3 Key

	// Get Sark's move when in single-player mode
	if (game_mode = 0 and (game_run_flag and egg_flag = 0)) then begin
		sark_move();
	end;
	
	if ( player_1_fire = 1 or player_2_fire = 1) then begin 
		returnvalue(true);
	end else begin
		returnvalue(false);
	end;
end;

// Displays game mode
procedure display_game_mode();
begin
	_A := CHR_COL_YEL;
    call(#$FFD2);

	tmp := (MYSCREEN_WIDTH/2) - 1;	// x pos
	if (game_mode = 0) then basic_printat(#msg_one_player,tmp,13);
	if (game_mode = 1) then basic_printat(#msg_two_player,tmp,13);
	//if (game_mode = 2 then basic_printat(#msg_tvs_player,tmp,13);
end;

// Displays game level
procedure display_game_difficulty();
begin
	_A := CHR_COL_YEL;
    call(#$FFD2);
	
	tmp := (MYSCREEN_WIDTH/2) + 5;	// x pos
	if (game_difficulty = 1) then basic_printat(#msg_diff_one, tmp, 15);
	if (game_difficulty = 2) then basic_printat(#msg_diff_two, tmp, 15);
	if (game_difficulty = 3) then basic_printat(#msg_diff_three, tmp, 15);
	if (game_mode = 1) then basic_printat(#msg_blank, tmp, 15);
end;

// Displays game mode
procedure display_game_controls();
begin
	_A := CHR_COL_YEL;
    call(#$FFD2);

	tmp := (MYSCREEN_WIDTH/2) + 3;	// x pos
	if control_mode = 0 then basic_printat(#msg_control_1,tmp,17);
	if control_mode = 1 then basic_printat(#msg_control_2,tmp,17);
end;

// Handle additional input during cycle text routine
procedure cycle_text_input_handler();
begin

	// Only check these inputs on title screen
	if (scroll_istitle = 1) then
	begin
		// one/two player mode change
		if (keybd_input = 5) then 
		begin
			game_mode_changed := 1;
			inc(game_mode);
			if (game_mode > 1) then game_mode := 0;
		end;	

		// difficulty selection change
		if (keybd_input = 6) then 
		begin
			game_mode_changed := 1;	
			inc(game_difficulty);
			if (game_difficulty > 3) then game_difficulty := 1;
		end;

		// control mode change
		if (keybd_input = 7) then
		begin
			game_mode_changed := 1;
			inc(control_mode);
			if (control_mode > 1) then control_mode := 0;
		end;
	
		// update display for controls
		if (game_mode_changed) then
		begin
			game_mode_changed := 0;
			display_game_mode();
			display_game_difficulty();
			display_game_controls();	
			do_delay(64);		
		end;
		
		// Help screen
		if (keybd_input = 4) then 
		begin
			// break out of cycle_text procedure
			scroll_inp_brk := 1;
			// show help screen
			help_screen();
		end;
	end;
	
	// Animations specific to easter egg screen
	if( scroll_iseegg ) then
	begin
		easter_egg_move_player();
	end;

	// Animate the scroll around title screen
	// Ideally this would run by IRQ
	play_title_animation();
end;

// Update score disp
procedure update_score(us_do_beep:boolean);
begin	
	if (game_mode) then begin
		// two player mode
		temp_byte1 := length(score_msg_0) + 1;
		temp_byte2 := MYSCREEN_WIDTH - (length(score_msg_1) + 2);
	end else begin
		// one player mode
		temp_byte1 := length(score_msg_2) + 1;
		temp_byte2 := MYSCREEN_WIDTH - (length(score_msg_3) + 2);
	end;

	// Update scores
	screen_loc[temp_byte1] := score_p1 + 48 + 128;
	screen_loc[temp_byte2] := score_p2 + 48 + 128;

	// Beep and flash score change
	if (us_do_beep) then
	begin
		// Initialze sound
		sound_init();
		
		// Setup sound
		LOC_FRELO1	:= 0;
		LOC_FREHI1	:= NOTE_5_E;
		LOC_ATDCY1	:= $18; // fastest attack, medium decay
		LOC_SUREL1	:= $81; // medium sustain, fastest release
		LOC_SIGVOL	:= $0F;
		
		for i := 0 to 4 do
		begin
			// Flash changed score
			if (player_1_crash) then begin
				screen_loc[temp_byte2] := screen_loc[temp_byte2] + 128;
			end;
			if (player_2_crash) then begin
				screen_loc[temp_byte1] := screen_loc[temp_byte1] + 128;
			end;

			// Sustain note
			LOC_VCREG1	:= %01000001;
			do_delay(128);

			// Sustain pause		
			LOC_VCREG1	:= %01000000;
			do_delay(128);
		end;
		
		// Turn off sound 
		LOC_SIGVOL	:= 0;
	end;
end;

// Show title screen
procedure title_screen();
begin
	// Vars indicate title screen active
	scroll_istitle := 1;
	scroll_ishelp := 0;
	scroll_iseegg := 0;

	// Set single color mode
	LOC_SCROLX := %00001000;

	// Stop sounds
	sound_stop();
		
	// init screen
	ClearScreen( 32, #LOC_CHAR_SCREEN); // init screen ram
	ClearScreen( BLUE, #SCREEN_COL_LOC); // init color ram

	// debug sound
	//sound_debug();
	
	// debug keyboard codes
	//check_keyboard_codes();

	// Draw box around screen
	draw_title_screen_box();	
		
	// Start animation interrupt
	//init_irq_animation();
	
	// Set color to white
	_A := CHR_COL_WHT;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - 18) / 2;

	// Display title messages
	basic_printat(#title_msg_1, tmp, 2);	// ptr, x, y
	basic_printat(#title_msg_2, tmp, 3);
	basic_printat(#title_msg_3, tmp, 4);
		
	_A := CHR_COL_GRN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(title_msg_4)) / 2;
	basic_printat(#title_msg_4, tmp, 6);
	tmp := (MYSCREEN_WIDTH - length(title_msg_5)) / 2;
	basic_printat(#title_msg_5, tmp, 8);
	
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(title_msg_6)) / 2;
	basic_printat(#title_msg_6, tmp, 11);
	tmp := (MYSCREEN_WIDTH - length(title_msg_7)) / 2;
	basic_printat(#title_msg_7, tmp, 13);
	tmp := (MYSCREEN_WIDTH - length(title_msg_8)) / 2;
	basic_printat(#title_msg_8, tmp, 15);	// string, xpos, ypos
	tmp := (MYSCREEN_WIDTH - length(title_msg_9)) / 2;
	basic_printat(#title_msg_9, tmp, 17);	// string, xpos, ypos

	_A := CHR_COL_CYN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(msg_get_ready)) / 2;
	basic_printat(#msg_get_ready, tmp, 21);
		
    // sprite attributes
	SPRITE_BITMASK			:= %00000111;	// enable sprites 0, 1, 2
	SPRITE_STRETCH_X			:= %00000011;	// expand sprites
	SPRITE_STRETCH_Y			:= %00000011;
	SPRITE_MULTICOLOR		:= %00000111;	// set multicolor mode
	SPRITE_MULTICOLOR_REG1	:= light_grey;
	SPRITE_MULTICOLOR_REG2	:= grey;	
	SPRITE_COLOR[0]			:= blue;
	SPRITE_COLOR[1]			:= red;
	SPRITE_COLOR[2]			:= yellow;

    // sprite positions 
    player_1_anim	:= 35;
    player_2_anim	:= 35;
    player_1_head	:= 10;
    player_2_head	:= 11;
	SpritePos(24 + 20,  45 + player_1_anim,  0);	// 24, 24 - top left		x, y, sprite #
	SpritePos(296 - 20, 45 + player_2_anim,  1);	// 296, 45 - top right
	SpritePos(175, 196,  2);					// 175, 196 - bee centered at bottom

	// sprite data locations
	sprite1_anim_idx	:= 0;
	sprite2_anim_idx	:= 0;
	poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + title_spr_arr_1[sprite1_anim_idx]); // addr, offset, value
	poke(LOC_SPRITE_PTRS, 1, sprite_def_loc + title_spr_arr_2[sprite2_anim_idx]);
	poke(LOC_SPRITE_PTRS, 2, sprite_def_loc + 8);	// bee

	// debug custom chars
	//debug_custom_chars();
	
	// Song to play	
	song_ptr := #theme_music_arr;	
	song_play_bass := 0;
//	song_ptr := #game_end_music_arr;
//	song_ptr := #keeping_up_music_arr;
//	song_bass_ptr := #keeping_up_bass_music_arr;
//	song_play_bass := 1;
//	song_tempo := 4;
	
	// Run input function within cycle routine
	scroll_input := 1;
	// Adjust scroll speed to compensate additional
	// CPU load for music & animation
	scroll_speed := scroll_speed - 6;

	// Print new round message & wait for input
	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 21, length(#msg_get_ready), 0, 0, 1, 1, 1);

	// Reset scroll speed	
	scroll_speed := DEF_SCROLL_SPEED;

	// Stop animation interrupt
	//Interrupts::Disable();
	
	scroll_istitle := 0;
end;

// Show help screen
procedure help_screen();
begin
	// Vars indicate help screen active
	scroll_istitle := 0;
	scroll_ishelp := 1;
	scroll_iseegg := 0;

	// Disable sprites
	SPRITE_BITMASK := 0;

	// Set multicolor mode
	LOC_SCROLX := %00011000;

	// Init the screen
	ClearScreen( 32, #LOC_CHAR_SCREEN); // init screen ram
	ClearScreen( BLUE, #SCREEN_COL_LOC); // init color RAM

	// Draw box around screen
	draw_title_screen_box();	
	
	// intro message
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(#help_msg_0)) / 2;
	basic_printat(#help_msg_0, tmp, 2);	// ptr, x, y
	
	// game instructions
	_A := CHR_COL_GRN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(#help_msg_1)) / 2;
	basic_printat(#help_msg_1, tmp, 4);	// ptr, x, y
	tmp := (MYSCREEN_WIDTH - length(#help_msg_2)) / 2;
	basic_printat(#help_msg_2, tmp, 5);
	tmp := (MYSCREEN_WIDTH - length(#help_msg_13)) / 2;
	basic_printat(#help_msg_13, tmp, 6);

	// menu controls
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_3)) /2;
	basic_printat(#help_msg_3, tmp, 8);
	_A := CHR_COL_GRN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_4)) / 2;
	basic_printat(#help_msg_4, tmp, 9);
	tmp := (MYSCREEN_WIDTH - length(help_msg_5)) / 2;
	basic_printat(#help_msg_5, tmp, 10);
	tmp := (MYSCREEN_WIDTH - length(help_msg_6)) / 2;
	basic_printat(#help_msg_6, tmp, 11);

	// player 1 controls
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_7)) / 2;
	basic_printat(#help_msg_7, tmp, 13);
	_A := CHR_COL_GRN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_8)) / 2;
	basic_printat(#help_msg_8, tmp, 14);
	tmp := (MYSCREEN_WIDTH - length(help_msg_9)) / 2;
	basic_printat(#help_msg_9, tmp, 15);

	// player 2 controls
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_10)) / 2;
	basic_printat(#help_msg_10, tmp, 17);
	_A := CHR_COL_GRN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(help_msg_11)) / 2;
	basic_printat(#help_msg_11, tmp, 18);
	tmp := (MYSCREEN_WIDTH - length(help_msg_12)) / 2;
	basic_printat(#help_msg_12, tmp, 19);

	// draw player 1 & 2 cycles
	screen_loc_work := screen_loc + (SCREEN_WIDTH * 13) + 21;
	screen_loc_work[2] := SCR_BIKE_LR_1;
	screen_loc_work[3] := SCR_BIKE_LR_2;
	color_loc_work := color_loc + (SCREEN_WIDTH * 13) + 21;
	color_loc_work[2] := 14; // blue mc
	color_loc_work[3] := 14;

	screen_loc_work := screen_loc + (SCREEN_WIDTH * 17) + 21;
	screen_loc_work[2] := SCR_BIKE_LR_1;
	screen_loc_work[3] := SCR_BIKE_LR_2;
	color_loc_work := color_loc + (SCREEN_WIDTH * 17) + 21;
	color_loc_work[2] := 10; // red mc
	color_loc_work[3] := 10;

	// press fire
	_A := CHR_COL_CYN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(msg_press_key)) / 2;
	basic_printat(#msg_press_key, tmp, 21);

	// Run input function within cycle routine
	scroll_input := 1;

	// Print new round message & wait for input
	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 21, length(#msg_press_key), 0, 0, 1, 1, 0);

	// Reset scroll speed	
	scroll_speed := DEF_SCROLL_SPEED;

	// Ensure game mode is redisplayed
	game_mode_changed := 1;

	// Pause a moment
	do_delay(128);

	// Show title screen
	title_screen();
end;

// Color all cycles on screen randomly
procedure easter_egg_color_cycles();
var
	eecc_temp1:	byte;
	eecc_temp2:	byte;
begin
	color_loc_work	:= color_loc;
	screen_loc_work 	:= screen_loc;
	
	for tmp := 0 to 1000 do
	begin
		eecc_temp1	:= peek(screen_loc_work,0);
		
		// horizontal bikes
		if (eecc_temp1 = SCR_BIKE_LR_1) then
		begin
			// This is a bike, pick a random color
			eecc_temp2 := (Random() / 32) + 8;	 	// get number from 9-15
			
			color_loc_work[0] := eecc_temp2;
			color_loc_work[1] := eecc_temp2;
		end;

		// vertical bikes
		if (eecc_temp1 = SCR_BIKE_UD_1) then
		begin
			// This is a bike, pick a random color
			eecc_temp2 := (Random() / 32) + 8;	// get number from 9-15
			
			color_loc_work[0] := eecc_temp2;
			color_loc_work[MYSCREEN_WIDTH] := eecc_temp2;
		end;
		
		inc(color_loc_work);
		inc(screen_loc_work);	
	end;
end;

// Draw & Color Easter Egg screen
procedure easter_egg_draw_screen();
begin
	// Init the screen
	ClearScreen( 32, #LOC_CHAR_SCREEN); // init screen ram
	ClearScreen( BLUE, #SCREEN_COL_LOC); // init color RAM

	// Draw box around screen
	draw_title_screen_box();	
	
	// congrats message
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(#msg_congrats_1)) / 2;
	basic_printat(#msg_congrats_1, tmp, 2);	// ptr, x, y
	tmp := (MYSCREEN_WIDTH - length(#msg_congrats_2)) / 2;
	basic_printat(#msg_congrats_2, tmp, 4);
	tmp := (MYSCREEN_WIDTH - length(#msg_congrats_3)) / 2;
	basic_printat(#msg_congrats_3, tmp, 5);
	
    // place sprite 
	SPRITE_BITMASK			:= %00000100;	// enable sprites 0, 1, 2
	SPRITE_STRETCH_X			:= %00000000;	// expand sprites
	SPRITE_STRETCH_Y			:= %00000000;
	SPRITE_MULTICOLOR		:= %00000100;	// set multicolor mode
	SPRITE_MULTICOLOR_REG1	:= black;
	SPRITE_MULTICOLOR_REG2	:= grey;	// light_blue;
	SPRITE_COLOR[2]			:= yellow;
	SpritePos(165, 115,  2); // position bee
	poke(LOC_SPRITE_PTRS, 2, sprite_def_loc + 8);	// sprite pointer
	
	// Place screen chars
	_A := CHR_COL_WHT;
    call(#$FFD2);
	basic_printat(#egg_screen_1, 2, 6);	// ptr, x, y
	basic_printat(#egg_screen_2, 2, 7);
	basic_printat(#egg_screen_3, 2, 8);
	basic_printat(#egg_screen_4, 2, 9);
	basic_printat(#egg_screen_5, 2, 10);
	basic_printat(#egg_screen_6, 2, 11);
	basic_printat(#egg_screen_7, 2, 12);
	basic_printat(#egg_screen_8, 2, 13);
	basic_printat(#egg_screen_9, 2, 14);
	basic_printat(#egg_screen_10, 2, 15);
	basic_printat(#egg_screen_11, 2, 16);
	basic_printat(#egg_screen_12, 2, 17);
	basic_printat(#egg_screen_13, 2, 18);
	basic_printat(#egg_screen_14, 2, 19);
	basic_printat(#egg_screen_15, 2, 20);
	basic_printat(#egg_screen_16, 2, 21);
	basic_printat(#egg_screen_17, 2, 22);
	basic_printat(#egg_screen_18, 2, 23);
	
	LOC_SCREEN_BGCOL1 := 15; // lt gray
	// Color building
	// need to make building a custom mc char to use colors 8-15
	//fori i := 7 to 17 do 
	fori i := 7 to 15 do 
	begin
		color_loc_work := color_loc + (SCREEN_WIDTH * i);
		fori j := 3 to 29 do color_loc_work[j] := 9;
	end;

	// Color grass
	color_loc_work := color_loc + (SCREEN_WIDTH * 7);
	fori i := 3 to 16 do color_loc_work[i] := 13;	// top side
	fori i := 16 to 20 do color_loc_work[i] := 13; // top side
	fori i := 20 to 29 do color_loc_work[i] := 13; // top side
	fori i := 8 to 14 do 
	begin
		color_loc_work := color_loc + (SCREEN_WIDTH * i);
		color_loc_work[3] := 13;	// left side
		color_loc_work[29] := 13; // right side
	end;
	color_loc_work := color_loc + (SCREEN_WIDTH * 15);
	fori i := 3 to 12 do color_loc_work[i] := 13;	// botttom side
	fori i := 18 to 29 do color_loc_work[i] := 13; // botttom side
	
	color_loc_work := color_loc + (SCREEN_WIDTH * 8);
	fori i := 16 to 24 do color_loc_work[i] := 13;	// MC green
	color_loc_work := color_loc + (SCREEN_WIDTH * 9); // courtyard
	fori i := 16 to 24 do color_loc_work[i] := 13;
	color_loc_work := color_loc + (SCREEN_WIDTH * 10); // courtyard
	fori i := 16 to 24 do color_loc_work[i] := 13;
	color_loc_work := color_loc + (SCREEN_WIDTH * 11); // courtyard
	fori i := 16 to 24 do color_loc_work[i] := 13;
	color_loc_work := color_loc + (SCREEN_WIDTH * 12); // courtyard
	fori i := 16 to 24 do color_loc_work[i] := 13;

	// Color text
	color_loc_work := color_loc + (SCREEN_WIDTH * 9);
	fori i := 5 to 11 do color_loc_work[i] := 1;
	color_loc_work := color_loc + (SCREEN_WIDTH * 10);
	fori i := 5 to 13 do color_loc_work[i] := 1;
	color_loc_work := color_loc + (SCREEN_WIDTH * 11);
	fori i := 5 to 12 do color_loc_work[i] := 1;	
	
	// Color cycles in parking lot
	easter_egg_color_cycles();	
end;

// Move the player's bike
procedure easter_egg_move_player();
begin
	// Do screen animations 
	if (turn_counter = 1) then
	begin
		if( player_1_anim = 0 ) then
		begin
			// Place player 
			player_1_head 		:= egg_move_arr[egg_arr_idx];		// get heading value from array
			player_1_trail[1]	:= player_1_trail[0];
			player_1_trail[0] 	:= screen_loc + player_1_xy;
			player_1_xy 			:= player_1_xy + dir_map_arr[player_1_head];
					
			inc(egg_arr_idx);
			if (dir_map_arr[player_1_head] = 0) then egg_arr_idx := 4;
		end;
		
		update_screen();
	end;
	
	inc(turn_counter);
	if (turn_counter > 5) then turn_counter := 0;
end;

// Show Easter Egg screen
procedure easter_egg_screen();
begin
	// Vars indicate help screen active
	scroll_istitle := 0;
	scroll_ishelp := 0;
	scroll_iseegg := 1;

	// Set multicolor mode
	LOC_SCROLX := %00011000;

	// stop sounds
	sound_stop();
	sound_init();
	song_ptr 		:= #game_end_music_arr;
	song_play_bass 	:= 0;
	LOC_SIGVOL		:= $0F;
	music_idx		:= 0;
	music_sust_idx	:= 0;

	// Flash the border and play end game music
	for i := 0 to (length(#game_end_music_arr) * song_tempo) do
	begin
		play_music();
		//inc(LOC_SCREEN_BORD);
		//inc(LOC_SCREEN_BACK);
		inc(LOC_SCREEN_BGCOL1);
		inc(LOC_SCREEN_BGCOL2); // bike wheels
		do_delay(DEF_SCROLL_SPEED);
	end;	
	
	// Draw & Color Easter Egg screen
	easter_egg_draw_screen();
	
	// Pause and stop any notes that might be playing
	// Start plaing music and doing animation
	sound_stop();
	do_delay(255);
	song_ptr 		:= #keeping_up_music_arr;
	song_bass_ptr 	:= #keeping_up_bass_music_arr;
	song_play_bass 	:= 1;
	song_tempo 		:= 4;
	LOC_SIGVOL		:= $0F;
	music_idx		:= 0;

	// Adjust scroll speed to compensate additional
	// CPU load for music & animation
	scroll_speed := scroll_speed - 5;

	// Set initial position of player's cycle
	player_1_xy 			:= 16 + MYSCREEN_WIDTH * 23;
	player_1_anim 		:= 0;
	turn_counter 		:= 1;
	player_1_trail[0]	:= screen_loc + player_1_xy;
	player_1_trail[1]	:= 0;
	player_1_trail[2]	:= 0;
	player_1_head 		:= 3; 	// 1=left, 2=right, 3=up, 4=down
	player_1_head_c 		:= player_1_head;
	egg_arr_idx			:= 0;
	trail_flag			:= 0;	// do not leave a trail
	
	// Animate & play music for some time, then drop into "press space" routine
	for tmp := 0 to 1200 do
	begin
		play_music();
		
		// Animate the scroll around title screen (Ideally this would run by IRQ)
		play_title_animation();
		
		// Move player's bike
		easter_egg_move_player();
		
		// sprite animation
		animate_bee();
		
		do_delay(scroll_speed);
	end;	

	// Display Press Space, continue music & animation
	_A := CHR_COL_CYN;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - length(msg_press_key)) / 2;
	basic_printat(#msg_press_key, tmp, 21);	// press space

	// Run input function within cycle routine
	scroll_input := 1;
		
	// Print new round message & wait for input
	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 21, length(#msg_press_key), 0, 0, 1, 1, 0);

	// Reset scroll speed & song temp
	scroll_speed 	:= DEF_SCROLL_SPEED;
	song_tempo		:= DEF_SONG_TEMPO;
	
	// Ensure game mode is redisplayed
	game_mode_changed := 1;

	// Reset egg_flag, scores, game speed & return to main loop
	egg_flag			:= 0;
	turn_counter		:= 0;
	player_1_fire	:= 0;
	player_2_fire	:= 0;
	player_1_input	:= 0;
	player_2_input	:= 0;
	score_p1			:= 0;
	score_p2			:= 0;
	player_1_crash	:= 0;
	player_2_crash	:= 0;
	game_speed		:= DEF_GAME_SPEED;
	game_over_flag	:= 1;
	game_run_flag	:= 0;
	
	// Pause a moment
	do_delay(255);
	do_delay(255);
end;


// Draw box around game screen
procedure draw_game_screen_box();
begin
	// Create address tables to screen memory and color RAM
    createaddresstable(#gamescreen_saddr, LOC_CHAR_SCREEN, MYSCREEN_WIDTH, MYSCREEN_HEIGHT+1);
    createaddresstable(#gamescreen_caddr, SCREEN_COL_LOC, MYSCREEN_WIDTH, MYSCREEN_HEIGHT+1);

    // Draw text box
	// [addresstable], [chararray], [column], [row], [width], [height] 
    drawtextbox(#gamescreen_saddr, #gamescreen_char_arr, 0, 1, MYSCREEN_WIDTH, MYSCREEN_HEIGHT);

    // Draw box colors to color RAM
    drawtextbox(#gamescreen_caddr, #gamescreen_color_arr, 0, 1, MYSCREEN_WIDTH, MYSCREEN_HEIGHT);
end;

// Setup game screen
procedure game_screen();
begin
	// Disable sprites
	SPRITE_BITMASK := 0;
	
	// Set multicolor mode
	LOC_SCROLX := %00011000;

	// stop any current sounds
	sound_stop();
	
	// init screen 
	ClearScreen( 32, #LOC_CHAR_SCREEN); // init screen ram
	ClearScreen( BLUE, #SCREEN_COL_LOC); // init color RAM

	// Draw box around screen
	draw_game_screen_box();
	
	// Draw score text display 
	if (game_mode = 0) then begin
		tmp := MYSCREEN_WIDTH - length(#score_msg_3)-1;
		basic_printat(#score_msg_2, 1, 0);	// string, x, y
		basic_printat(#score_msg_3, tmp, 0);	// string, x, y
	end;
	if (game_mode = 1) then begin
		tmp := MYSCREEN_WIDTH - length(#score_msg_1);
		basic_printat(#score_msg_0, 1, 0);	// string, x, y
		basic_printat(#score_msg_1, tmp-1, 0);	// string, x, y
	end;
	
	// Set color for top row
	for i := 0 to SCREEN_WIDTH do begin
		color_loc[i] := 5;
	end;
	
	update_score(0);
	init_engine_sound();
	init_gamestate();
end;

// Start new round
procedure new_round();
begin
	// Set color yellow
	_A := CHR_COL_YEL;
    call(#$FFD2);

	// Print crash message
	do_delay(64);
	tmp := (MYSCREEN_WIDTH - message_len) / 2;
	basic_printat(message_ptr, tmp, 12);	// string, x, y
	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 12, message_len, 3, 1, 0, 0, 0);

	// Beep and flash score change
	update_score(1);
	do_delay(64);

	// Clear message	
	tmp := (MYSCREEN_WIDTH - length(msg_blank)) / 2;
	basic_printat(#msg_blank, tmp, 12);
	
	// Set color
	_A := CHR_COL_CYN;
    call(#$FFD2);

	// Print new round message & wait for input
	tmp := (MYSCREEN_WIDTH - length(msg_get_ready)) / 2;
	basic_printat(#msg_get_ready, tmp, 12);
	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 12, length(#msg_get_ready), 0, 0, 1, 0, 0);

	// Adjust game speed
	if( score_p1 = 1 or score_p2 = 1 ) then game_speed := DEF_GAME_SPEED - 5;
	if( score_p1 = 2 or score_p2 = 2 ) then game_speed := DEF_GAME_SPEED - 10;
	if( score_p1 = 3 or score_p2 = 3 ) then game_speed := DEF_GAME_SPEED - 15;
	if( score_p1 = 4 or score_p2 = 4 ) then game_speed := DEF_GAME_SPEED - 20;

	// Redraw game screen
	game_screen();
end;

// Start new game
procedure end_game();
begin
	update_score(0);
	sound_stop();
	
    // place sprite - winning cycle
	SPRITE_BITMASK			:= %00000001;	// enable sprite 0
	SPRITE_STRETCH_X			:= %00000001;	// expand sprites
	SPRITE_STRETCH_Y			:= %00000001;
	SPRITE_MULTICOLOR		:= %00000001;	// set multicolor mode
	SPRITE_MULTICOLOR_REG1	:= light_grey;
	SPRITE_MULTICOLOR_REG2	:= grey;	
	SPRITE_COLOR[0]			:= temp_byte3;
	SpritePos(155, 125,  0); // position cycle
	poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + 0);	// sprite pointer
	
	// Print Game Over message
	_A := CHR_COL_YEL;
    call(#$FFD2);
	tmp := (MYSCREEN_WIDTH - message_len) / 2;
	basic_printat(message_ptr, tmp, 14);	// string, x, y

	// Cycle text, wait for input, & play music
	song_ptr := #game_end_music_arr;
	song_play_bass := 0;

	// xpos, ypos, # chars, # cycles, direction, input break, play music, init music 
	cycle_text(tmp, 14, message_len, 30, 0, 0, 1, 1);
	
	// Reset scores, game speed & return to main loop
	score_p1	:= 0;
	score_p2	:= 0;
	game_speed := DEF_GAME_SPEED;
	game_over_flag := 1;
end;

// Game state
procedure check_game_state();
begin
	// Check quit game hotkey 
	if (keybd_input = 8) then 
	begin
		// Reset scores, game speed & return to main loop
		game_run_flag	:= 0;
		game_over_flag	:= 1;
		score_p1			:= 0;
		score_p2			:= 0;
		egg_flag			:= 0;
		game_speed 		:= DEF_GAME_SPEED;
		scroll_speed 	:= DEF_SCROLL_SPEED;
		anim_speed		:= DEF_ANIM_SPEED;
		
		do_delay(255);
		do_delay(255);
	end;	

	// Check for player crashed
	if (player_1_crash = 1 or player_2_crash = 1) then begin
		player_crash();
		LOC_VCREG1 := 0;
		game_run_flag := 0;
	end;

	if (player_1_crash = 1 and player_2_crash = 1) then begin
		message_ptr := #msg_both_crash;
		message_len := length(msg_both_crash);
		new_round();
	end 
	else if (player_1_crash = 1 ) then begin
		// Increment score 
		inc(score_p2);
		
		if (score_p2 < SCORE_TO_WIN) then 
		begin
			if (game_mode = 0) then
			begin
				message_ptr := #msg_plr_crash;
				message_len := length(msg_plr_crash);
			end else begin
				message_ptr := #msg_p1_crash;
				message_len := length(msg_p1_crash);
			end;
			
			new_round();
		end;
	end
	else if (player_2_crash = 1 and egg_flag = 0) then begin
		// Increment score 
		inc(score_p1);
		
		if (score_p1 < SCORE_TO_WIN) then begin
			if (game_mode = 0) then begin
				message_ptr := #msg_sark_crash;
				message_len := length(msg_sark_crash);
			end else begin 
				message_ptr := #msg_p2_crash;
				message_len := length(msg_p2_crash);
			end;

			new_round();
		end;
	end
	else if (egg_flag = 1) then
	begin
		// Activate easter egg
		// Erase all trails & explosion parts from screen
		// Let player continue to drive
		
		// Continue game
		game_run_flag := 1;
		
		// Re-init sound
		init_engine_sound();
				
		// Clear bike trails & wreckage
		if (wiped_flag = 0) then 
		begin
			// Increment P2 position - grid border where crash happened
			player_2_xy := player_2_xy + dir_map_arr[player_2_head];

			wipe_bike_trails();
			wiped_flag := 1;
		end;
	end;
	
	// Check for end of game
	if (score_p1 >= SCORE_TO_WIN) then 
	begin
		if (game_mode = 0) then begin
			message_ptr := #msg_plr_wins;
			message_len := length(msg_plr_wins);
		end else begin
			message_ptr := #msg_p1_wins;
			message_len := length(msg_p1_wins);
		end;

		temp_byte3 := blue;	// color of winning cycle
		end_game();
	end
	else if (score_p2 >= SCORE_TO_WIN) then 
	begin
		if (game_mode = 0) then begin
			message_ptr := #msg_sark_wins;
			message_len := length(msg_sark_wins);
		end else begin
			message_ptr := #msg_p2_wins;
			message_len := length(msg_p2_wins);
		end;

		temp_byte3 := red;	// color of winning cycle
		end_game();
	end;
end;

// Check Collisions
//	player_1_xy, player_2_xy 		- Player Coordinates
//	player_1_crash, player_2_crash	- Crash Flags
procedure check_collisions();
begin
	player_1_crash := 0;
	player_2_crash := 0;

	// Both crashed before trail is drawn. This solves edge case 
	// when both players try to occupy the same location.
	if (player_1_xy = player_2_xy) then 
	begin
		if (egg_flag = 0) then begin
			player_1_crash := 1;
			player_2_crash := 1;
		end else begin
			// Activate Easter Egg screen
			easter_egg_screen();
		end;
	end;
	
	if (player_1_anim = 0 and (turn_counter or player_1_fire) ) then 
	begin
		// Check if P1 crashed
		// Check 'move to' position for crash
		screen_loc_work := screen_loc + player_1_xy;
		temp_byte1 := peek(screen_loc_work, 0);
	
		if (temp_byte1 <> CHR_SPC ) then player_1_crash := 1;
	end;

	if (egg_flag = 0 and (player_2_anim = 0 and (turn_counter or player_2_fire))) then 
	begin
		// Check if P2 crashed
		// Check 'move to' position for crash
		screen_loc_work := screen_loc + player_2_xy;
		temp_byte1 := peek(screen_loc_work, 0);
		
		// Check for easter egg activation
		if (game_mode = 0 and
			(score_p1 > 0 and
			(temp_byte1 = SCR_GAME_TB_HORIZ or 
			(temp_byte1 = SCR_GAME_RT_VERT or 
			(temp_byte1 = SCR_GAME_LT_VERT))))) then
		begin
			// Activate easter egg mode
			egg_flag := 1;
		end;
		
		if ( temp_byte1 <> CHR_SPC ) then player_2_crash := 1;
	end;
end;

// Check & return distance to crash_anim_arr
function sark_crash_distance(scd_head:byte) : byte;
var
	scd_i:		byte;
	scd_crash:	byte;
	scd_tmp_int:	integer;
begin
	scd_i := 0;
	scd_crash := 0;
	scd_tmp_int := player_2_xy;

	while (scd_crash = 0) do
	begin
		inc(scd_i);	// number of moves until crash
		scd_tmp_int := scd_tmp_int + dir_map_arr[scd_head]; // increment pos
		screen_loc_work := screen_loc + scd_tmp_int;
		if (peek(screen_loc_work, 0) <> CHR_SPC) then scd_crash := 1;
	end;
	
	sark_crash_distance := scd_i;
end;

// Check Sark's distance to player in x and y dirs
procedure sark_check_player_dist();
var
	scpd_sark_x : byte;
	scpd_sark_y : byte;
	scpd_player_x : byte;
	scpd_player_y : byte;
begin
	//	sark_near_player_x_dist: byte;
	//	sark_near_player_x_neg:	boolean;	// left is neg
	//	sark_near_player_y_dist:	byte;
	//	sark_near_player_y_neg:	boolean;	// up is neg

	// Determine Sark's XY position
	scpd_sark_y := player_2_xy / MYSCREEN_WIDTH;
	scpd_sark_x := player_2_xy - (scpd_sark_y * MYSCREEN_WIDTH);
	// Derermine player's XY position
	scpd_player_y := player_1_xy / MYSCREEN_WIDTH;
	scpd_player_x := player_1_xy - (scpd_player_y * MYSCREEN_WIDTH);

	if (scpd_sark_y > scpd_player_y) then
	begin
		sark_near_player_y_neg := 1;	// player is above Sark
		sark_near_player_y_dist := scpd_sark_y - scpd_player_y;
	end else
	begin
		sark_near_player_y_neg := 0;	// player is below Sark
		sark_near_player_y_dist := scpd_player_y - scpd_sark_y;
	end;

	if (scpd_sark_x > scpd_player_x) then
	begin
		sark_near_player_x_neg := 1;	// player is left of Sark
		sark_near_player_x_dist := scpd_sark_x - scpd_player_x;
	end else
	begin
		sark_near_player_x_neg := 0;	// player is right of Sark
		sark_near_player_x_dist := scpd_player_x - scpd_sark_x;
	end;
	
end;

//	Sark's logic routine to box in opponent & avoid crashing.
//  Sets: player_2_input, player_2_fire
procedure sark_move();
var
	sm_tmp_int:		integer;
	sm_cr_dist:		byte;
	sm_cr_dist_l:	byte;
	sm_cr_dist_r:	byte;
	sm_cr_dist_u:	byte;
	sm_cr_dist_d:	byte;
	sm_head:			byte;	
	sm_i:			byte;
begin
	player_2_input	:= 0;
	player_2_fire	:= 0;
	sm_cr_dist		:= sark_crash_distance(player_2_head);
	sm_cr_dist_l		:= sark_crash_distance(1);
	sm_cr_dist_r		:= sark_crash_distance(2);
	sm_cr_dist_u		:= sark_crash_distance(3);
	sm_cr_dist_d		:= sark_crash_distance(4);

	// Check relative position of player
	sark_check_player_dist();

	//	Check distance on current heading to obstacle.  
	//	If both turn options are elegible, turn towards player.
	//	Otherwise, turn in direction with greater distance.
	if (sm_cr_dist < sark_crash_thold) then
	begin
		// crash imminent, check other directions
		if (player_2_head = 1 or player_2_head = 2) then
		begin
			// Sark is moving L or R. Check U/D
			// If both alternatives have 'good' crash distance, randomly choose
			if (sm_cr_dist_u > sark_crash_thold and sm_cr_dist_d > sark_crash_thold) then begin
				// logic to choose random direction
				if (Random() > 127) then begin
					player_2_input := 4;
				end else begin
					player_2_input := 3;
				end;
				
				//	logic to turn away from player
				//if (bot_near_player_y_neg) then begin
				//	player_2_input := 4;
				//end else begin
				//	player_2_input := 3;
				//end;
			end else
			begin
				// Take direction with best crash distance
				if (sm_cr_dist_u > sm_cr_dist_d and sm_cr_dist_u > sm_cr_dist) then begin
					player_2_input := 3;
				end else if(sm_cr_dist_d > sm_cr_dist) then begin
					player_2_input := 4;
				end;
			end;

		end else if (player_2_head = 3 or player_2_head = 4) then
		begin
			// Sark is moving U or D. Check L/R
			// If both alternatives have 'good' crash distance, randomly choose
			if (sm_cr_dist_l > sark_crash_thold and sm_cr_dist_r > sark_crash_thold) then begin
				// logic to choose random direction
				if (Random() > 127) then begin
					player_2_input := 2;
				end else begin
					player_2_input := 1;
				end;

				//	logic to turn away from player
				//if (bot_near_player_x_neg) then begin
				//player_2_input := 2;
				//end else begin
				//	player_2_input := 1;
				//end;
			end else
			begin
				// Take direction with best crash distance
				if (sm_cr_dist_l > sm_cr_dist_r and sm_cr_dist_l > sm_cr_dist) then begin
					player_2_input := 1;
				end else if(sm_cr_dist_r > sm_cr_dist) then begin
					player_2_input := 2;
				end;
			end;
		end;
	end;

	if( game_difficulty = 2 or game_difficulty = 3 ) then
	begin
		//	If opponent less than 'n' moves away, engage turbo boost 
		//	unless it would cause a crash.
		if (sm_cr_dist > 1) then
		begin
			if (sark_near_player_x_dist < sark_boost_thold and 
				sark_near_player_y_dist < sark_boost_thold) then
			begin
				player_2_fire := 1;
			end;
		end;
	end;

	if( game_difficulty = 3 ) then
	begin
		//	If within player proximity, both have same heading, AND
		//	player's row/col is open at Sark's row/col position,
		//	then cut off the player 
		if (sark_near_player_x_dist <= sark_prox_thold and sark_near_player_y_dist <= sark_prox_thold) then
		begin
			// Sark is moving left/right
			if (player_2_head = 1 or player_2_head = 2) then
			begin
				if (sark_near_player_y_neg and sm_cr_dist_u > 1) then 
				begin
					// Player is above Sark, and move available
					player_2_input := 3; // move up
				end else if (sark_near_player_y_neg = 0 and sm_cr_dist_d > 1) then 
				begin
					// Player is below Sark, and move available
					player_2_input := 4; // move down
				end;	
			end;
	
			// Sark is moving up/down
			if (player_2_head = 3 or player_2_head = 4) then
			begin
				if (sark_near_player_x_neg and sm_cr_dist_l > 1) then 
				begin
					// Player is left of Sark, and move available
					player_2_input := 1; // move left
				end else if (sark_near_player_x_neg = 0 and sm_cr_dist_r > 1) then 
				begin
					// Player is below Sark, and move available
					player_2_input := 2; // move right
				end;			
			end;
		end;
	end;

	// DEBUG
	//	moveto(1,1,hi(screen_char_loc));
	//	printstring("MOVING DN",0,9);
end;


// Update Positions
// 	player_1_xy, player_2_xy 		- Player Coordinates
// 	player_1_head, player_2_head 		- Player Headings 
// 	player_1_fire, player_2_fire 		- Turbo Engaged
// 	player_1_trail, player_2_trail 	- Trail Positions 
procedure update_positions();
begin
	// Check if move avail
	inc(turn_counter);
	if turn_counter > 1 then turn_counter := 0; 	// May need to tweak this value
	
	// Move P1 if normal move or turbo engaged
	if ( player_1_anim = 0 and (turn_counter = 1 or player_1_fire = 1) ) then
	begin
		// Verify input was received and not opposite of current dir
		if (player_1_input and (player_1_input <> dir_opp_arr[player_1_head])) then
		begin
			// Set new heading
			player_1_head	:= player_1_input;
		end;

		// Update trail register
		player_1_trail[2]	:= player_1_trail[1];
		player_1_trail[1]	:= player_1_trail[0];
		player_1_trail[0]	:= screen_loc + player_1_xy;
		
		// Update Player 1 Position
		if (player_1_head) then player_1_xy := player_1_xy + dir_map_arr[player_1_head];
	end;

	// Move P2 if normal move is available or turbo engaged
	if ( egg_flag = 0 and (player_2_anim = 0 and (turn_counter = 1 or player_2_fire = 1)) ) then
	begin
		// Verify input was received and not opposite of current dir
		if (player_2_input and (player_2_input <> dir_opp_arr[player_2_head])) then
		begin
			// Set new heading
			player_2_head	:= player_2_input;
		end;

		// Update trail register
		player_2_trail[2]	:= player_2_trail[1];
		player_2_trail[1]	:= player_2_trail[0];
		player_2_trail[0]	:= screen_loc + player_2_xy;

		// Update Player 2 Position
		if (player_2_head) then player_2_xy := player_2_xy + dir_map_arr[player_2_head];
	end;
end;

// Determine trailing character
function return_trail_char(rtc_new_pos:byte, rtc_old_pos:byte) : byte;
var
	rtc_return:	byte;
begin
	if (rtc_new_pos = rtc_old_pos) then 
	begin
		// Draw trail horiz & ver
		if (rtc_old_pos = 1 or rtc_old_pos = 2) then begin
			rtc_return := trail_char_arr[0];
		end else begin
			rtc_return := trail_char_arr[1];
		end;
	end else
	begin
		// 1=L, 2=R, 3=U, 4=D
		// 0=H, 1=V, 2=LT, 3=RT, 4=LB, 5=RB
		if (rtc_new_pos = 1 and rtc_old_pos = 3 ) then begin
			rtc_return := trail_char_arr[2];	// left top corner
		end
		else if (rtc_new_pos = 1 and rtc_old_pos = 4) then begin
			rtc_return := trail_char_arr[4];	// left bot corner
		end 
		else if (rtc_new_pos = 2 and rtc_old_pos = 3) then begin
			rtc_return := trail_char_arr[3];	// right top corner
		end
		else if (rtc_new_pos = 2 and rtc_old_pos = 4) then begin
			rtc_return := trail_char_arr[5];	// right bot corner
		end
		else if (rtc_new_pos = 3 and rtc_old_pos = 1) then begin
			rtc_return := trail_char_arr[5];	// right bot corner 
		end 
		else if (rtc_new_pos = 3 and rtc_old_pos = 2) then begin
			rtc_return := trail_char_arr[4];	// left bot corner 
		end 
		else if (rtc_new_pos = 4 and rtc_old_pos = 1) then begin
			rtc_return := trail_char_arr[3];	// top right corner
		end 
		else if (rtc_new_pos = 4 and rtc_old_pos = 2) then begin
			rtc_return := trail_char_arr[2];	// top left corner
		end;
	end;

	return_trail_char := rtc_return;
end;

// Determine bike characters to use
procedure populate_bike_chars(pbc_heading:byte, pbc_heading_old:byte, pbc_anim_frame:byte);
begin
	// If player turning, key animation frame 1
	if( pbc_heading <> pbc_heading_old ) then pbc_anim_frame := 1;
	// Return value of pbc_anim_frame
	temp_byte1 := pbc_anim_frame;
	
	if (pbc_anim_frame = 0) then 
	begin
		// dir_map_arr:	1=L, 2=R, 3=U, 4=D
		if (pbc_heading = 1 ) then begin
			player_char_1	:= SCR_BIKE_LT_MID_1;
			player_char_2	:= SCR_BIKE_LR_MID_2;
			player_char_3	:= SCR_BIKE_LT_MID_3;
			// Don't show trail on char 3 when trail disableds
			if (trail_flag = 0) then player_char_3	:= SCR_BIKE_RT_MID_3;
		end else if (pbc_heading = 2 ) then begin
			player_char_1	:= SCR_BIKE_RT_MID_3;
			player_char_2	:= SCR_BIKE_LR_MID_2;
			player_char_3	:= SCR_BIKE_RT_MID_1;
			// Don't show trail on char 3 when trail disableds
			if (trail_flag = 0) then player_char_3	:= SCR_BIKE_LT_MID_1;
		end else if (pbc_heading = 3 ) then begin
			player_char_1	:= SCR_BIKE_UP_MID_1;
			player_char_2	:= SCR_BIKE_UD_MID_2;
			player_char_3	:= SCR_BIKE_UP_MID_3;
			// Don't show trail on char 3 when trail disableds
			if (trail_flag = 0) then player_char_3	:= SCR_BIKE_DN_MID_3;
		end else if (pbc_heading = 4 ) then begin
			player_char_1	:= SCR_BIKE_DN_MID_3;
			player_char_2	:= SCR_BIKE_UD_MID_2;
			player_char_3	:= SCR_BIKE_DN_MID_1;
			// Don't show trail on char 3 when trail disableds
			if (trail_flag = 0) then player_char_3	:= SCR_BIKE_UP_MID_1;
		end;
		
	end else 
	begin
		// dir_map_arr:	1=L, 2=R, 3=U, 4=D
		if (pbc_heading = 1 ) then begin
			player_char_1	:= SCR_BIKE_LR_1;
			player_char_2	:= SCR_BIKE_LR_2;
		end else if (pbc_heading = 2 ) then begin
			player_char_1	:= SCR_BIKE_LR_2;
			player_char_2	:= SCR_BIKE_LR_1;
		end else if (pbc_heading = 3 ) then begin
			player_char_1	:= SCR_BIKE_UD_1;
			player_char_2	:= SCR_BIKE_UD_2;
		end else if (pbc_heading = 4 ) then begin
			player_char_1	:= SCR_BIKE_UD_2;
			player_char_2	:= SCR_BIKE_UD_1;
		end;
	end;	
end;

// Update Screen
//	player_1_xy, player_2_xy - Player Coordinates 	
//	player_1_trail, player_2_trail - Trail Coordinates
procedure update_screen();
begin
	// Move Player 1
	if (turn_counter = 1 or player_1_fire = 1) then
	begin
		// Get chars
		populate_bike_chars(player_1_head, player_1_head_c, player_1_anim);
		// Get value set in populate_bike_chars 
		player_1_anim := temp_byte1;
	
		// P1 bike chars
		screen_loc_work		:= screen_loc + player_1_xy;
		screen_loc_work[0]	:= player_char_1;
		screen_loc_work		:= player_1_trail[0];
		screen_loc_work[0]	:= player_char_2;

		// P1 bike color
		color_loc_work		:= color_loc + player_1_xy;
		color_loc_work[0]	:= 14; // blue mc
		color_loc_work		:= color_loc - screen_loc + player_1_trail[0];
		color_loc_work[0]	:= 14;

		if (player_1_anim = 0) then
		begin
			// Mid-frame bike/trail part
			screen_loc_work		:= player_1_trail[1];
			screen_loc_work[0]	:= player_char_3;
			color_loc_work		:= color_loc - screen_loc + player_1_trail[1];
			color_loc_work[0]	:= 14; // blue mc
		end else
		begin
			// Full frame trail part
			if (trail_flag) then
			begin
				screen_loc_work		:= player_1_trail[1];
				screen_loc_work[0]	:= player_1_trail_char;
				player_1_trail_char	:= return_trail_char(player_1_head, player_1_head_c);
				color_loc_work		:= color_loc - screen_loc + player_1_trail[1];
				color_loc_work[0]	:= 6; // blue
			end else 
			begin
				screen_loc_work		:= player_1_trail[1];
				screen_loc_work[0]	:= SCR_SPC;
			end;
		end;

		// Increment animation
		inc(player_1_anim);
		if (player_1_anim > 1) then player_1_anim := 0;

		// Save old player headings
		player_1_head_c	:= player_1_head;
	end;

	// Move Player 2
	if (egg_flag = 0 and (turn_counter = 1 or player_2_fire = 1)) then
	begin
		// Get chars
		populate_bike_chars(player_2_head, player_2_head_c, player_2_anim);
		// Get value set in populate_bike_chars 
		player_2_anim := temp_byte1;
	
		// P1 bike chars
		screen_loc_work		:= screen_loc + player_2_xy;
		screen_loc_work[0]	:= player_char_1;
		screen_loc_work		:= player_2_trail[0];
		screen_loc_work[0]	:= player_char_2;

		// P1 bike color
		color_loc_work		:= color_loc + player_2_xy;
		color_loc_work[0]	:= 10; // red mc
		color_loc_work		:= color_loc - screen_loc + player_2_trail[0];
		color_loc_work[0]	:= 10;

		if (player_2_anim = 0) then
		begin
			// Mid-frame bike/trail part
			screen_loc_work		:= player_2_trail[1];
			screen_loc_work[0]	:= player_char_3;
			color_loc_work		:= color_loc - screen_loc + player_2_trail[1];
			color_loc_work[0]	:= 10; // red mc
		end else
		begin
			// Full frame trail part
			screen_loc_work		:= player_2_trail[1];
			screen_loc_work[0]	:= player_2_trail_char;
			player_2_trail_char	:= return_trail_char(player_2_head, player_2_head_c);
			color_loc_work		:= color_loc - screen_loc + player_2_trail[1];
			color_loc_work[0]	:= 2; // red	
		end;

		// Increment animation
		inc(player_2_anim);
		if (player_2_anim > 1) then player_2_anim := 0;

		// Save old player headings
		player_2_head_c	:= player_2_head;
	end;
end;

// Init Variables
procedure init_gamestate();
begin
	player_1_xy			:= 5 + (12 * MYSCREEN_WIDTH);
	player_2_xy			:= MYSCREEN_WIDTH -6 + (12 * MYSCREEN_WIDTH);
	player_1_head		:= 2; // heading right
	player_2_head		:= 1; // heading left
	player_1_head_c		:= player_1_head;
	player_2_head_c		:= player_2_head;
	player_1_trail[0]	:= 0;
	player_2_trail[0]	:= 0;
	player_1_trail_char  := SCR_TRAIL_HORIZ;
	player_2_trail_char  := SCR_TRAIL_HORIZ;
	player_1_crash		:= 0;
	player_2_crash		:= 0;
	player_1_input		:= 0;
	player_2_input		:= 0;
	player_1_fire		:= 0;
	player_2_fire		:= 0;
	turn_counter			:= 0;
	player_1_anim		:= 0;
	player_2_anim		:= 0;
	scroll_input			:= 0;
	game_run_flag		:= 1;
	game_mode_changed	:= 1;
	egg_flag				:= 0;
	wiped_flag			:= 0;
	trail_flag			:= 1;
	song_tempo			:= DEF_SONG_TEMPO;
end;


// Draw box around title screen
procedure draw_title_screen_box();
var
	dtsb_tmp : byte;
	dtsb_i : byte;
begin	
	// Draw top and bottom	
	screen_loc_work	:= screen_loc + MYSCREEN_WIDTH * MYSCREEN_HEIGHT;

	for dtsb_i := 0 to MYSCREEN_WIDTH step 2 do
	begin
		screen_loc[dtsb_i]		:= SCR_SOLID_BLOCK;
		screen_loc_work[dtsb_i]	:= SCR_SOLID_BLOCK;
		screen_loc[dtsb_i+1]		:= SCR_SHADED_BLOCK;
		screen_loc_work[dtsb_i+1]:= SCR_SHADED_BLOCK;
   	end;
	
	// Draw sides
	for dtsb_i := 0 to MYSCREEN_HEIGHT step 2 do
	begin
		dtsb_tmp := MYSCREEN_WIDTH-1;
		screen_loc_work	:= screen_loc + (dtsb_tmp * dtsb_i);
		screen_loc_work[dtsb_i]							:= SCR_SOLID_BLOCK;
		screen_loc_work[dtsb_i+dtsb_tmp]					:= SCR_SHADED_BLOCK;
		screen_loc_work[dtsb_i+MYSCREEN_WIDTH]			:= SCR_SHADED_BLOCK;
		screen_loc_work[dtsb_i+MYSCREEN_WIDTH+dtsb_tmp]	:= SCR_SOLID_BLOCK;
	end;
end;

// Animate characters around title screen
procedure play_title_animation();
var
	pta_tmp	: byte;
	pta_i	: byte;
begin
	// defines colors 3=cyan, 5=green, 6=blue, 7=yellow	
	temp_byte1 := 3;	// shaded blocks
	temp_byte2 := 6;	// solid blocks

	if anim_speed = 0 then
	begin
		// Top/bottom sides
		for pta_i := 0 to MYSCREEN_WIDTH do
		begin
			// Top
			screen_loc_work := screen_loc + pta_i;
			color_loc_work := color_loc + pta_i;

			// Update chars
			if (peek(screen_loc_work, 0) = SCR_SOLID_BLOCK) then begin
				screen_loc_work[0] := SCR_SHADED_BLOCK;
				color_loc_work[0] := temp_byte1;
			end else begin
				screen_loc_work[0] := SCR_SOLID_BLOCK;			
				color_loc_work[0] := temp_byte2;			
			end;	

			// Bottom
			screen_loc_work	:= screen_loc + pta_i + (MYSCREEN_WIDTH * MYSCREEN_HEIGHT);
			color_loc_work	:= color_loc + pta_i + (MYSCREEN_WIDTH * MYSCREEN_HEIGHT);
			
			if (peek(screen_loc_work, 0) = SCR_SOLID_BLOCK) then begin
				screen_loc_work[0] := SCR_SHADED_BLOCK;
				color_loc_work[0] := temp_byte1;
			end else begin
				screen_loc_work[0] := SCR_SOLID_BLOCK;			
				color_loc_work[0] := temp_byte2;
			end;		
		end;

		// Left/Right sides
		for pta_i := 1 to MYSCREEN_HEIGHT do
		begin
			// Left
			screen_loc_work	:= screen_loc + pta_i * MYSCREEN_WIDTH;
			color_loc_work	:= color_loc + pta_i * MYSCREEN_WIDTH;
			
			if (peek(screen_loc_work, 0) = SCR_SOLID_BLOCK) then begin
				screen_loc_work[0] := SCR_SHADED_BLOCK;
				color_loc_work[0] := temp_byte1;
			end else begin
				screen_loc_work[0] := SCR_SOLID_BLOCK;			
				color_loc_work[0] := temp_byte2;
			end;		

			// Right
			screen_loc_work	:= screen_loc + (pta_i * MYSCREEN_WIDTH) + MYSCREEN_WIDTH -1;
			color_loc_work	:= color_loc + (pta_i * MYSCREEN_WIDTH) + MYSCREEN_WIDTH -1;
			
			if (peek(screen_loc_work, 0) = SCR_SOLID_BLOCK) then begin
				screen_loc_work[0] := SCR_SHADED_BLOCK;
				color_loc_work[0] := temp_byte1;
			end else begin
				screen_loc_work[0] := SCR_SOLID_BLOCK;			
				color_loc_work[0] := temp_byte2;
			end;	
		end;
		
		// Reset animation counter 
		anim_speed := DEF_ANIM_SPEED;
	end;
	
	dec(anim_speed);
end;
	
// Runs on IRQ
// I must be doing something wrong here, stack seems to get corrupted
/*
procedure do_irq_animation();
begin
 	Interrupts::StartIRQ();

	// Play animation
	play_title_animation();
	
	// Play music inside the cycle_text() function instead for 2001 compatibility
	//play_music();
	
	inc(tmp_irq);

	// DEBUG counter
	moveto(41,0,hi(screen_char_loc));
	printdecimal(tmp_irq,2);
	
	Interrupts::CloseIRQ();
end;

// Routine to animate & play music via raster interrupt
// NOTE: It seems only one interrupt can be running at a given time
// NOTE: Raster not available on PET 2001 - use only for non-critical functions.
procedure init_irq_animation();
begin
	tmp_irq := 0;
	
	// Set interrupt function & enable
	Interrupts::Disable();
	Interrupts::RasterIRQ(#do_irq_animation);
	Interrupts::Enable();
end;
*/

// crash visual & sound effect
procedure player_crash();
begin	
	// Animate crash & make sound
	tmp := 0;
	sound_stop();
	
	// Max vol, use noise waveform
	LOC_SIGVOL	:= $0F;
	LOC_ATDCY1	:= $0F;
	LOC_SUREL1	:= $F1;
	LOC_FRELO1	:= 0;	
	LOC_VCREG1	:= %10000001;
	
    // place sprite - explosion
    explode_anim_idx := 0;
   	SPRITE_STRETCH_X	 := %00000011;	// expand sprites
	SPRITE_STRETCH_Y	 := %00000011;
	SPRITE_COLOR[0]	 := light_grey;
	SPRITE_COLOR[1]	 := light_grey;
 
    if player_1_crash then begin
    		temp_spr_y	:= player_1_xy / MYSCREEN_WIDTH; // Y value
	    temp_spr_x	:= player_1_xy - (temp_spr_y * MYSCREEN_WIDTH);	// X value
	    
	    ToggleBit(SPRITE_BITMASK, 0, 1);	// location, bit position, bit value
		SpritePos( 4+(temp_spr_x * 8), 32+(temp_spr_y * 8), 0); // x, y, sprite #
		poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + explode_spr_arr[explode_anim_idx]);	// first explosion sprite
	end;

    if player_2_crash then begin
    		temp_spr_y := player_2_xy / MYSCREEN_WIDTH; // Y value
	    temp_spr_x := player_2_xy - (temp_spr_y * MYSCREEN_WIDTH);	// X value
	    
	    ToggleBit(SPRITE_BITMASK, 1, 1);	// location, bit position, bit value
		SpritePos( 4+(temp_spr_x * 8), 32+(temp_spr_y * 8), 1); // x, y, sprite #
		poke(LOC_SPRITE_PTRS, 1, sprite_def_loc + explode_spr_arr[explode_anim_idx]);	// first explosion sprite
	end;
	
	fori i := 0 to 22 step 1 do
	begin
		// Sprite animation
		if (explode_anim_idx < length(explode_spr_arr)-1) then
		begin
			inc(explode_anim_idx);
			poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + explode_spr_arr[explode_anim_idx]);	// explosion sprites
			poke(LOC_SPRITE_PTRS, 1, sprite_def_loc + explode_spr_arr[explode_anim_idx]);	// explosion sprites
		end else begin
			SPRITE_BITMASK := %00000000;	// disable sprites
		end;
		
		// Char animation		
		inc(tmp);
		if tmp > 3 then tmp := 0;
		
		if player_1_crash then begin
			// Explode impact point
			screen_loc_work := screen_loc + player_1_xy;
			screen_loc_work[0] := crash_anim_arr[tmp];
			color_loc_work := color_loc + player_1_xy;
			color_loc_work[0] := crash_color_arr[tmp];
			// Explode bike
			screen_loc_work := player_1_trail[0];
			screen_loc_work[0] := crash_anim_arr[tmp];
			screen_loc_work := player_1_trail[1];
			screen_loc_work[0] := crash_anim_arr[tmp];
			color_loc_work := color_loc - screen_loc + player_1_trail[0];
			color_loc_work[0] := crash_color_arr[tmp];
			color_loc_work := color_loc - screen_loc + player_1_trail[1];
			color_loc_work[0] := crash_color_arr[tmp];	
		end;
		if player_2_crash then begin
			// Explode impact point
			screen_loc_work := screen_loc + player_2_xy;
			screen_loc_work[0] := crash_anim_arr[tmp];
			color_loc_work := color_loc + player_2_xy;
			color_loc_work[0] := crash_color_arr[tmp];
			// Explode bike
			screen_loc_work := player_2_trail[0];
			screen_loc_work[0] := crash_anim_arr[tmp];
			screen_loc_work := player_2_trail[1];
			screen_loc_work[0] := crash_anim_arr[tmp];
			color_loc_work := color_loc - screen_loc + player_2_trail[0];
			color_loc_work[0] := crash_color_arr[tmp];
			color_loc_work := color_loc - screen_loc + player_2_trail[1];
			color_loc_work[0] := crash_color_arr[tmp];
		end;

		// Sound Effect
		// LOC_FREHI1	:= i + 8;
		if (tmp = 0) then begin
			LOC_FREHI1	:= 4;
		end else if (tmp = 1) then begin
			LOC_FREHI1	:= 8;
		end else if (tmp = 2) then begin 
			LOC_FREHI1	:= 16;
		end else begin
			LOC_FREHI1	:= 64;
		end;
		
		// Cycle border color 
		//LOC_SCREEN_BORD := crash_bord_arr[tmp];
		//LOC_SCREEN_BGCOL1 := tmp;
		LOC_SCREEN_BGCOL2 := crash_bord_arr[tmp];

		do_delay(48);
	end;
	
	// Reset SID settings
	sound_init();
	
	// Reset screen/border color 
	LOC_SCREEN_BORD := 0;
	LOC_SCREEN_BGCOL1 := 14; // lt blue
	LOC_SCREEN_BGCOL2 := 15;	// lt gray
end;

// init engine sound
procedure init_engine_sound();
begin
	// Initialze sound
	sound_init();

	// Max vol
	LOC_SIGVOL	:= $0F;

	// set pitch 
	sound_pitch	:= 5;
	
	alternate_engine_sound();
end;
	
// alt engine sound
procedure alternate_engine_sound();
begin
	// Using voice 2
	LOC_VCREG2	:= %00100000; // release note

	// Iterate through several pitch values
	if (sound_pitch = 5) then begin
		sound_pitch := 10;
		LOC_SCREEN_BGCOL1 := 14;	// Flash multicolor game border
	end
	else if (sound_pitch = 10) then begin
		sound_pitch := 15;
		LOC_SCREEN_BGCOL1 := 3;
	end
	else if (sound_pitch = 15) then begin
		sound_pitch := 5;
		LOC_SCREEN_BGCOL1 := 14;
	end;
	
	// Use higher pitch when turbo is engaged
	if (player_1_fire or player_2_fire) then begin
		// make high engine sound
		LOC_FRELO2	:= 0;
		LOC_FREHI2	:= sound_pitch * 2;
	end 	else begin
		// make low engine sound
		LOC_FRELO2	:= 0;
		LOC_FREHI2	:= sound_pitch;
	end;
	
	LOC_VCREG2	:= %00100001; // begin note
end;

// Erase bike trails & wreckage
procedure wipe_bike_trails();
begin
	j := 0;
	
	// Flash color of trails and play end game music
	for i := 0 to 9 do
	begin
		screen_loc_work	:= screen_loc;
		color_loc_work	:= color_loc;

		while (screen_loc_work < 1000 + screen_loc) do
 		begin 
			// Alternate trail color
			temp_byte1 := peek(screen_loc_work, 0);
			
			if (temp_byte1 = SCR_TRAIL_HORIZ or 
				(temp_byte1 = SCR_TRAIL_VERT or 
				(temp_byte1 = SCR_TRAIL_LT_CORNER or 
				(temp_byte1 = SCR_TRAIL_RT_CORNER or
				(temp_byte1 = SCR_TRAIL_LB_CORNER or 
				(temp_byte1 = SCR_TRAIL_RB_CORNER)))))
			   ) 
			then	 begin
				color_loc_work[0] := crash_bord_arr[j];
	 		end;
	 		
			inc(screen_loc_work);
	 		inc(color_loc_work);
		end;

		// Alternate color
		inc(j);
		if (j > length(crash_bord_arr)-1 ) then j := 0;
	end; 	

	// Reset to top of screen	
	screen_loc_work	:= screen_loc;

	while (screen_loc_work < 1000 + screen_loc) do
 	begin 
		// Replace trails & debris with space
		temp_byte1 := peek(screen_loc_work, 0);

		if (temp_byte1 = SCR_TRAIL_HORIZ or 
			(temp_byte1 = SCR_TRAIL_VERT or 
			(temp_byte1 = SCR_TRAIL_LT_CORNER or 
			(temp_byte1 = SCR_TRAIL_RT_CORNER or
			(temp_byte1 = SCR_TRAIL_LB_CORNER or 
			(temp_byte1 = SCR_TRAIL_RB_CORNER or
			(temp_byte1 = SCR_EXPLODE))))))
		   ) 
		then begin
			screen_loc_work[0] := 32;
		end;
		
		inc(screen_loc_work);
	end;
end;

// Cycle colors of game logo & cycle sprites
procedure animate_game_logo();
begin
	inc(temp_byte3);
	if (temp_byte3 >= length(logo_color_arr)) then temp_byte3 := 0;

	for j := 0 to 18 do begin
		color_loc_work		:= color_loc + (MYSCREEN_WIDTH * 2) + (MYSCREEN_WIDTH - 18) / 2;
		color_loc_work[j] 	:= logo_color_arr[temp_byte3];
		
		color_loc_work		:= color_loc_work + MYSCREEN_WIDTH;
		color_loc_work[j] 	:= logo_color_arr[temp_byte3];
		
		color_loc_work		:= color_loc_work + MYSCREEN_WIDTH;
		color_loc_work[j] 	:= logo_color_arr[temp_byte3];
	end;
	
	// Move left big cycle
	if( player_1_anim > 135 or player_1_anim < 35 ) then begin
		// Animate sprite rotation
		if( player_1_anim > 135 ) then begin
			inc(sprite1_anim_idx);
			poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + title_spr_arr_1[sprite1_anim_idx]); // addr, offset, value
		end else begin
			dec(sprite1_anim_idx);
			poke(LOC_SPRITE_PTRS, 0, sprite_def_loc + title_spr_arr_2[sprite1_anim_idx]); // addr, offset, value
		end;
		
		// Move sprite position
		if(sprite1_anim_idx = 5 or sprite1_anim_idx = 0 ) then begin
			player_1_head := -player_1_head;
			player_1_anim := player_1_anim + player_1_head;
			SpritePos(24 + 20, 45 + player_1_anim,  0);	// x, y, sprite #
		end;
		
	end else begin
		// Move sprite
		player_1_anim := player_1_anim + player_1_head;
		SpritePos(24 + 20, 45 + player_1_anim,  0);
	end;

	// Move right big cycle
	if( player_2_anim > 135 or player_2_anim < 35 ) then begin
		// Animate sprite rotation
		if( player_2_anim > 135 ) then begin
			inc(sprite2_anim_idx);
			poke(LOC_SPRITE_PTRS, 1, sprite_def_loc + title_spr_arr_1[sprite2_anim_idx]); // addr, offset, value
		end else begin
			dec(sprite2_anim_idx);
			poke(LOC_SPRITE_PTRS, 1, sprite_def_loc + title_spr_arr_2[sprite2_anim_idx]); // addr, offset, value
		end;
		
		// Move sprite position
		if(sprite2_anim_idx = 5 or sprite2_anim_idx = 0 ) then begin
			player_2_head := -player_2_head;
			player_2_anim := player_2_anim + player_2_head;
			SpritePos(296 - 20, 45 + player_2_anim,  1);	// x, y, sprite #
		end;

	end else begin
		// Move sprite
		player_2_anim := player_2_anim + player_2_head;
		SpritePos(296 - 20, 45 + player_2_anim,  1);
	end;
	
end;

// Animate bee sprite
procedure animate_bee();
begin
	// Animate bee
	poke(LOC_SPRITE_PTRS, 2, sprite_def_loc + bee_spr_arr[bee_anim_idx]);	// bee

	if(bee_anim_idx = 0) then begin
		bee_anim_idx := 1;
	end else begin
		bee_anim_idx := 0;
	end;	
end;

// eof