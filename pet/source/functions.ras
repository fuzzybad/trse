
//	Method to get a char from the keyboard buffer
//	TRSE procedures return accumulator value
procedure GetKey();
begin
	call(^$ffe4);	// getin
end;

// Wait for user input
procedure WaitForKeypress();
begin
	// Pause until key pressed
	temp := 0;
	while( temp = 0 ) do begin
		temp := GetKey();
	end;
end;

// Do timing delay 
// @TODO: Find better way than delay loop
procedure DoDelay();
begin
	if( speed > 0 ) then
	begin
		for i := 0 to speed do	
		begin
			wait(255);
		end;
	end;
end;

// Debug up to 3 numeric vars
procedure PrintXYZ( myX:signed byte, myY:signed byte, myZ:signed byte );
begin
	// Erase & print values
	moveto(1, 5, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myX, 2);

	moveto(1, 6, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myY, 2);

	moveto(1, 7, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myZ, 2);
end;

// Determine screen width to use
procedure SetScreenWidth();
begin
	// Determine PET model by checking first byte of EDIT ROM at $E000
	//	$A0 [160] = B1
	//	$48 [72]  = B2
	//	$36 [54]  = B4-40
	//	$4B [75]  = B4-80	
	if( peek(^$E000, 1) = 75 ) then 
	begin
		myscreenwidth := 80;
		// Set Graphics mode, with compact lines
		asm("
		    lda $8e;
		    jsr $ffd2;
		    ");
	end else myscreenwidth := 40;

	centerX := myscreenwidth / 2 - 1;
	clearscreen($20, SCREEN_CHAR_LOC);
end;


// Fill char array
procedure InitData();
begin
	// Set center based on screen width setting
	//centerX := myscreenwidth / 2 - 1;
	
	for i := 0 to num_chars do							// line 150
	begin
		// Populate char_arr with 50/50 split between these ranges:
		// 65-128 and 193-256
		char_start := char_start_st;
		char_offset := char_offset_st;
		
		// Option for reverse chars
		if( rev_enable = 1 ) then
		begin
			if( Random() > 127 ) then				// line 165
				char_start := char_start + 128;		// line 165
		end;
		
		char_arr[i] := Random() & char_offset + char_start;
	end;
end; 

// Check for any user inputs
procedure CheckInputs();
begin	
	key := GetKey();

	// Q - Quit
	if(key = 81) then begin
		clearscreen($20, SCREEN_CHAR_LOC);
		//call(^$fd49);	// NMI	    
		call(^$fd16);	// RESET		
	end;
	
	// 0-9 Adjust speed 
	if(key = 48) then speed := 9; // (slowest)
	if(key = 49) then speed := 8;
	if(key = 50) then speed := 7;
	if(key = 51) then speed := 6;
	if(key = 52) then speed := 5;
	if(key = 53) then speed := 4;
	if(key = 54) then speed := 3;
	if(key = 55) then speed := 2;
	if(key = 56) then speed := 1;
	if(key = 57) then speed := 0; // (fastest)
		
	// S - Toggle 40/80 Col Screen
	if(key = 83) then
	begin
		if( myscreenwidth = 40 ) then myscreenwidth := 80
		else myscreenwidth := 40;

		centerX := myscreenwidth / 2 - 1;
		clearscreen($20, SCREEN_CHAR_LOC);
	end;
end;


// Poke value into an address
procedure PokeAddr(pokeaddr_x:byte, pokeaddr_y:byte, pokeaddr_v:byte);
begin
	if( pokeaddr_x > myscreenwidth - 1 ) then return;
	if( pokeaddr_x < 0) then return;
	if( pokeaddr_y > SCREEN_HEIGHT - 1 ) then return;
	if( pokeaddr_y < 0) then return;
	
	// Pointer to screen RAM
	p := SCREEN_CHAR_LOC + myscreenwidth * pokeaddr_y + pokeaddr_x;

	poke(p, 0, pokeaddr_v);
end;

