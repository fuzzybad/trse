
//	Method to get a char from the keyboard buffer
//	TRSE procedures return accumulator value
procedure GetKey();
begin
	call(^$ffe4);	// getin
end;

// Wait for user input
procedure WaitForKeypress();
begin
	// Pause until key pressed
	temp := 0;
	while( temp = 0 ) do begin
		temp := GetKey();
	end;
end;

// Do timing delay 
// @TODO: Find better way than delay loop
procedure DoDelay(mydelay:byte);
begin
	if( mydelay > 0 ) then
	begin
		for i := 0 to mydelay do	
		begin
			wait(255);
		end;
	end;
end;

// Debug up to 3 numeric vars
procedure PrintXYZ( myX:integer, myY:signed byte, myZ:signed byte );
begin
	// Erase & print values
	moveto(1, 5, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 4);
	PrintDecimal(myX, 4);

	moveto(1, 6, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myY, 2);

	moveto(1, 7, hi(SCREEN_CHAR_LOC));
	PrintDecimal(0, 2);
	PrintDecimal(myZ, 2);
end;

// Determine screen width to use
procedure SetScreenWidth();
begin
	// Determine PET model by checking first byte of EDIT ROM at $E000
	//	$A0 [160] = B1
	//	$48 [72]  = B2
	//	$36 [54]  = B4-40
	//	$4B [75]  = B4-80	
	if( peek(^$E000, 1) = 75 ) then 
	begin
		myscreenwidth := 80;
		// Set Graphics mode, with compact lines
		asm("
		    lda $8e;
		    jsr $ffd2;
		    ");
	end else myscreenwidth := 40;

	centerX := myscreenwidth / 2 - 1;
	clearscreen($20, SCREEN_CHAR_LOC);
end;

// Check for any user inputs
procedure CheckInputs();
begin	
	key := GetKey();

	// Q - Quit
	if(key = 81) then begin
		clearscreen($20, SCREEN_CHAR_LOC);
		//call(^$fd49);	// NMI	    
		call(^$fd16);	// RESET		
	end;
	
	// 0-9 Adjust speed 
	if(key = 48) then speed := 18; // (slowest)
	if(key = 49) then speed := 16;
	if(key = 50) then speed := 14;
	if(key = 51) then speed := 12;
	if(key = 52) then speed := 10;
	if(key = 53) then speed := 8;
	if(key = 54) then speed := 6;
	if(key = 55) then speed := 4;
	if(key = 56) then speed := 2;
	if(key = 57) then speed := 0; // (fastest)
		
	// S - Toggle 40/80 Col Screen
	if(key = 83) then
	begin
		if( myscreenwidth = 40 ) then myscreenwidth := 80
		else myscreenwidth := 40;

		centerX := myscreenwidth / 2 - 1;
		clearscreen($20, SCREEN_CHAR_LOC);
	end;
end;

// Poke value into an address
procedure PokeAddr(pokeaddr_x:signed byte, pokeaddr_y:signed byte, pokeaddr_v:byte);
begin
	if( pokeaddr_x > myscreenwidth - 1 ) then return;
	if( pokeaddr_x < 0) then return;
	if( pokeaddr_y > SCREEN_HEIGHT - 1 ) then return;
	if( pokeaddr_y < 0) then return;
	
	// Using AddressTable for screen updates
	// This is faster than using poke()
	p := AddressTable( #saddr, pokeaddr_x, pokeaddr_y );
	p[0] := pokeaddr_v;
	
	// Pointer to screen RAM
	//p := SCREEN_CHAR_LOC + myscreenwidth * pokeaddr_y + pokeaddr_x;
	//poke(p, 0, pokeaddr_v);
end;

